<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Interno - Multimodal</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root {
            --primary: #667eea;
            --primary-hover: #5568d3;
            --secondary: #764ba2;
            --accent: #f093fb;
            --success: #25d366;
            --bg-dark: #0f0f23;
            --bg-card: rgba(15, 23, 42, 0.75);
            --glass-border: rgba(148, 163, 184, 0.3);
            --text-primary: #f8fafc;
            --text-secondary: rgba(226, 232, 240, 0.85);
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.2);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.3);
            --shadow-xl: 0 12px 48px rgba(0, 0, 0, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 25%, #16213e 50%, #1a1a2e 75%, #0f0f23 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            min-height: 100vh;
            color: var(--text-primary);
            overflow: hidden;
            position: relative;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .chat-container {
            display: flex;
            height: 100vh;
            max-width: 1600px;
            margin: 0 auto;
            background: var(--bg-card);
            backdrop-filter: blur(30px) saturate(180%);
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-xl);
            border-radius: 0;
            overflow: hidden;
        }

        /* Sidebar de usuários */
        .users-sidebar {
            width: 360px;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.95) 0%, rgba(15, 23, 42, 0.85) 100%);
            border-right: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: var(--shadow-md);
            position: relative;
        }

        .users-sidebar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
            opacity: 0.5;
        }

        .sidebar-header {
            padding: 1.75rem 1.5rem;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: var(--shadow-sm);
            position: relative;
            z-index: 1;
        }

        .sidebar-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }

        .sidebar-header h3 {
            margin: 0;
            font-size: 1.35rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* Container de busca de usuários */
        .users-search-container {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--glass-border);
            background: rgba(15, 23, 42, 0.6);
        }

        .users-search-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .users-search-icon {
            position: absolute;
            left: 1rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
            z-index: 1;
            pointer-events: none;
        }

        .users-search-input {
            width: 100%;
            padding: 0.75rem 2.75rem 0.75rem 2.75rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.1);
            border-radius: 14px;
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .users-search-input:not(:placeholder-shown) {
            padding-right: 3.5rem;
        }

        .users-search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }

        .users-search-input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(255, 255, 255, 0.12);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1), var(--shadow-sm);
        }

        .users-search-clear {
            position: absolute;
            right: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            width: 26px;
            height: 26px;
            display: none;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.8rem;
            z-index: 2;
        }

        .users-search-clear:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .users-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .user-item {
            padding: 1.25rem 1rem;
            margin: 0.5rem;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid transparent;
            position: relative;
            overflow: hidden;
        }

        .user-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--primary);
            transform: scaleY(0);
            transition: transform 0.3s ease;
            border-radius: 0 2px 2px 0;
        }

        .user-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(102, 126, 234, 0.3);
            transform: translateX(4px);
            box-shadow: var(--shadow-sm);
        }

        .user-item:hover::before {
            transform: scaleY(1);
        }

        .user-item.active {
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.25) 0%, rgba(102, 126, 234, 0.15) 100%);
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .user-item.active::before {
            transform: scaleY(1);
        }

        .user-avatar {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.25rem;
            margin-right: 1rem;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .user-item:hover .user-avatar {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
        }

        .user-info {
            flex: 1;
        }

        .user-name {
            font-weight: 600;
            margin-bottom: 0.375rem;
            font-size: 0.95rem;
            letter-spacing: -0.2px;
        }

        .user-status {
            font-size: 0.8rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 9px;
            height: 9px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
            box-shadow: 0 0 8px rgba(37, 211, 102, 0.5);
            border: 1.5px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0;
        }
        
        .status-dot.offline {
            background: #6b7280;
            animation: none;
            box-shadow: 0 0 4px rgba(107, 114, 128, 0.3);
        }

        @keyframes pulse {
            0%, 100% { 
                opacity: 1;
                transform: scale(1);
            }
            50% { 
                opacity: 0.7;
                transform: scale(1.1);
            }
        }

        .unread-badge {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border-radius: 14px;
            padding: 0.35rem 0.65rem;
            font-size: 0.75rem;
            font-weight: 700;
            margin-left: auto;
            min-width: 24px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(239, 68, 68, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: pulseBadge 2s ease-in-out infinite;
        }

        /* Estilos para grupos */
        .group-item {
            position: relative;
        }

        .group-item .user-avatar {
            background: linear-gradient(135deg, #f093fb 0%, #764ba2 100%);
        }

        .group-item .group-icon {
            position: absolute;
            bottom: -2px;
            right: -2px;
            background: var(--primary);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            border: 2px solid var(--bg-card);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .btn-create-group {
            margin: 0.75rem 1rem;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            border: none;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .btn-create-group:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
        }

        .btn-create-group:active {
            transform: translateY(0);
        }

        /* Modal de grupos */
        .modal-grupo {
            background: var(--bg-card);
            backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            color: var(--text-primary);
        }

        .modal-grupo .modal-header {
            border-bottom: 1px solid var(--glass-border);
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            border-radius: 20px 20px 0 0;
            padding: 1.5rem;
        }

        .modal-grupo .modal-title {
            color: white;
            font-weight: 700;
        }

        .modal-grupo .modal-body {
            padding: 1.5rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        .modal-grupo .form-label {
            color: var(--text-primary);
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .modal-grupo .form-control {
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: var(--text-primary);
            padding: 0.75rem 1rem;
        }

        .modal-grupo .form-control:focus {
            background: rgba(255, 255, 255, 0.12);
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            color: var(--text-primary);
        }

        .participantes-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 1rem;
        }

        .participante-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 12px;
            margin-bottom: 0.5rem;
            transition: all 0.2s ease;
        }

        .participante-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .participante-item input[type="checkbox"] {
            margin-right: 0.75rem;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .participante-item .participante-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
            margin-right: 0.75rem;
        }

        .participante-item .participante-info {
            flex: 1;
        }

        .participante-item .participante-nome {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .participante-item .participante-departamento {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        @keyframes pulseBadge {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 3px 10px rgba(239, 68, 68, 0.4);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 4px 14px rgba(239, 68, 68, 0.6);
            }
        }

        /* Área de chat */
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            padding: 1.25rem 1.75rem;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.95) 0%, rgba(15, 23, 42, 0.85) 100%);
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: var(--shadow-sm);
            position: relative;
            z-index: 10;
        }

        .chat-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.3), transparent);
        }

        .chat-header-info {
            display: flex;
            align-items: center;
            gap: 1.25rem;
        }

        .chat-header-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.1rem;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .chat-header-name {
            font-weight: 600;
            font-size: 1.15rem;
            letter-spacing: -0.3px;
        }

        .chat-header .text-muted {
            font-size: 0.85rem;
            color: var(--text-secondary);
            opacity: 0.8;
            margin-top: 0.125rem;
            display: block;
        }

        .chat-header-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-icon {
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            padding: 0.625rem 0.875rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }

        .btn-icon:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-sm);
        }

        /* Separador de data (estilo WhatsApp) */
        .message-date-separator {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 2rem 0;
            position: relative;
        }

        .message-date-separator::before,
        .message-date-separator::after {
            content: '';
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
        }

        .message-date-separator-text {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9) 0%, rgba(15, 23, 42, 0.7) 100%);
            padding: 0.625rem 1.25rem;
            border-radius: 24px;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin: 0 1.25rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(10px);
            letter-spacing: 0.3px;
        }

        /* Modal de busca */
        .search-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(8px);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .search-modal-content {
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(15, 23, 42, 0.95) 100%);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            width: 90%;
            max-width: 650px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(30px);
        }

        .search-modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .search-modal-header h5 {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .search-modal-close {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .search-modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .search-modal-body {
            padding: 1.5rem;
            flex: 1;
            overflow-y: auto;
        }

        .search-input-wrapper {
            position: relative;
            margin-bottom: 1.5rem;
        }

        .search-input {
            width: 100%;
            padding: 0.875rem 1.125rem 0.875rem 3.25rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            color: var(--text-primary);
            font-size: 1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(255, 255, 255, 0.12);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1), var(--shadow-sm);
        }

        .search-input-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }

        .search-results {
            max-height: 400px;
            overflow-y: auto;
        }

        .search-empty {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-secondary);
        }

        .search-empty i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .search-result-item {
            padding: 1.125rem 1.25rem;
            margin-bottom: 0.625rem;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid transparent;
            backdrop-filter: blur(10px);
        }

        .search-result-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(102, 126, 234, 0.4);
            transform: translateX(6px);
            box-shadow: var(--shadow-sm);
        }

        .search-result-item.highlighted {
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.25) 0%, rgba(102, 126, 234, 0.15) 100%);
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .search-result-text {
            margin-bottom: 0.5rem;
            line-height: 1.5;
        }

        .search-result-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .search-highlight {
            background: rgba(102, 126, 234, 0.3);
            padding: 0.1rem 0.2rem;
            border-radius: 4px;
            font-weight: 600;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 2rem 1.75rem;
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.3) 0%, rgba(15, 23, 42, 0.5) 100%);
            position: relative;
        }

        .chat-messages::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.2), transparent);
        }

        .message {
            display: flex;
            gap: 0.875rem;
            max-width: 75%;
            animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(15px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .message.sent {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message.received {
            align-self: flex-start;
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.95rem;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .message-content {
            background: rgba(255, 255, 255, 0.08);
            padding: 0.875rem 1.125rem;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
            position: relative;
        }

        .message-content::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 20px;
            padding: 1px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), transparent);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .message:hover .message-content::before {
            opacity: 1;
        }

        .message.sent .message-content {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }

        .message.sent .message-content::before {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), transparent);
        }

        .message-text {
            margin-bottom: 0.375rem;
            word-wrap: break-word;
            white-space: pre-wrap;
            line-height: 1.5;
            letter-spacing: 0.01em;
        }

        .message-footer {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 0.5rem;
            margin-top: 0.25rem;
        }

        .message.sent .message-footer {
            justify-content: flex-start;
        }

        .message-time {
            font-size: 0.7rem;
            opacity: 0.75;
            font-weight: 500;
            letter-spacing: 0.3px;
        }

        .message-status {
            display: flex;
            align-items: center;
            gap: 0.1rem;
            font-size: 0.7rem;
        }

        .message-status-icon {
            font-size: 0.7rem;
            line-height: 1;
        }

        .message-status-sent {
            color: rgba(255, 255, 255, 0.5);
        }

        .message-status-delivered {
            color: rgba(255, 255, 255, 0.7);
        }

        .message.sent .message-status-delivered {
            color: rgba(255, 255, 255, 0.7);
        }

        .message-status-read {
            color: #4FC3F7;
        }

        .message.sent .message-status-read {
            color: #4FC3F7;
        }

        /* Garantir que os vistos sejam visíveis nas mensagens enviadas */
        .message.sent .message-status {
            opacity: 1;
        }

        .message.highlighted {
            animation: highlightMessage 3s ease;
            position: relative;
        }

        .message.highlighted::before {
            content: '';
            position: absolute;
            left: -10px;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--primary);
            border-radius: 2px;
            animation: highlightBorder 3s ease;
        }

        @keyframes highlightMessage {
            0% {
                background: rgba(102, 126, 234, 0.4);
                transform: scale(1.03);
                box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
            }
            50% {
                background: rgba(102, 126, 234, 0.3);
                transform: scale(1.01);
                box-shadow: 0 0 15px rgba(102, 126, 234, 0.4);
            }
            100% {
                background: transparent;
                transform: scale(1);
                box-shadow: none;
            }
        }

        @keyframes highlightBorder {
            0% {
                opacity: 1;
                width: 4px;
            }
            100% {
                opacity: 0;
                width: 0;
            }
        }

        .message-file {
            margin-bottom: 0.5rem;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--glass-border);
        }

        .message-file-image {
            max-width: 100%;
            max-height: 300px;
            width: auto;
            height: auto;
            display: block;
            cursor: pointer;
            transition: transform 0.2s ease;
            border-radius: 12px;
            object-fit: contain;
            background: rgba(0, 0, 0, 0.1);
        }

        .message-file-image:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        /* Modal para visualizar imagens */
        .image-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            cursor: pointer;
            animation: fadeIn 0.3s ease;
        }

        .image-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .image-modal-content {
            max-width: 90%;
            max-height: 90%;
            width: auto;
            height: auto;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: zoomIn 0.3s ease;
            display: block !important;
            pointer-events: auto;
            z-index: 10001;
            position: relative;
            cursor: default;
        }

        @keyframes zoomIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .image-modal-close {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10002;
            pointer-events: auto;
        }

        .image-modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .image-modal-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 25px;
        }

        .image-modal-actions {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 10002;
        }

        .image-modal-btn {
            background: rgba(102, 126, 234, 0.9);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
        }

        .image-modal-btn:hover {
            background: rgba(102, 126, 234, 1);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
        }

        .image-modal-btn.secondary {
            background: rgba(118, 75, 162, 0.9);
        }

        .image-modal-btn.secondary:hover {
            background: rgba(118, 75, 162, 1);
        }

        .image-modal-btn i {
            font-size: 1rem;
        }

        /* Botões de grupo */
        .btn-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .btn-icon {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
            padding: 0.5rem 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .btn-icon:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .btn-danger {
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border: none;
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 1);
        }

        .message-file-document {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            text-decoration: none;
            color: var(--text-primary);
            transition: background 0.2s ease;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .message-file-document:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        /* Preview de PDF */
        .message-file-pdf-preview {
            margin-top: 0.5rem;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .message-file-pdf-preview iframe {
            width: 100%;
            height: 400px;
            border: none;
            display: block;
        }

        .message-file-pdf-actions {
            display: flex;
            gap: 0.5rem;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-pdf-download {
            flex: 1;
            padding: 0.5rem 1rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn-pdf-download:hover {
            background: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .message-file-icon {
            font-size: 2rem;
            color: var(--primary);
        }

        .message-file-info {
            flex: 1;
            min-width: 0;
        }

        .message-file-name {
            font-weight: 600;
            margin-bottom: 0.25rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .message-file-size {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .message-file-download {
            color: var(--primary);
            font-size: 1.2rem;
        }

        .message-actions {
            display: none;
            position: absolute;
            right: 0.5rem;
            top: 0.5rem;
            gap: 0.5rem;
        }

        .message:hover .message-actions {
            display: flex;
        }

        .btn-reply {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 0.4rem 0.6rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .btn-reply:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .message-reply-preview {
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid var(--primary);
            padding: 0.5rem 0.75rem;
            margin-bottom: 0.5rem;
            border-radius: 8px;
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .message-reply-preview-author {
            font-weight: 600;
            margin-bottom: 0.2rem;
            font-size: 0.75rem;
        }

        .message-reply-preview-text {
            opacity: 0.9;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .reply-preview-container {
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.15) 0%, rgba(102, 126, 234, 0.05) 100%);
            border-left: 3px solid var(--primary);
            padding: 0.875rem 1.125rem;
            margin-bottom: 0.875rem;
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(10px);
        }

        .reply-preview-content {
            flex: 1;
        }

        .reply-preview-author {
            font-weight: 600;
            font-size: 0.85rem;
            margin-bottom: 0.25rem;
            color: var(--primary);
        }

        .reply-preview-text {
            font-size: 0.8rem;
            opacity: 0.8;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .reply-preview-close {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-primary);
            transition: all 0.2s ease;
            margin-left: 0.5rem;
        }

        .reply-preview-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .message {
            position: relative;
        }

        .chat-input-area {
            padding: 1.5rem 1.75rem;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.95) 0%, rgba(15, 23, 42, 0.85) 100%);
            border-top: 1px solid var(--glass-border);
            position: relative;
            box-shadow: 0 -4px 16px rgba(0, 0, 0, 0.2);
        }

        .chat-input-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.3), transparent);
        }

        .input-group {
            display: flex;
            gap: 0.875rem;
            align-items: center;
        }

        .chat-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.1);
            border-radius: 28px;
            padding: 0.875rem 1.5rem;
            color: var(--text-primary);
            font-size: 0.95rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            resize: none;
            overflow-y: auto;
            min-height: 52px;
            max-height: 150px;
            line-height: 1.5;
            font-family: inherit;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .chat-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(255, 255, 255, 0.12);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1), var(--shadow-sm);
        }
        
        /* Estilizar scrollbar do textarea */
        .chat-input::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-input::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        .chat-input::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 3px;
        }
        
        .chat-input::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.7);
        }

        .btn-send {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--success) 0%, #20ba5a 100%);
            border: none;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            flex-shrink: 0;
            box-shadow: 0 4px 12px rgba(37, 211, 102, 0.3);
            font-size: 1.1rem;
        }

        .btn-send:hover:not(:disabled) {
            transform: scale(1.08) rotate(5deg);
            box-shadow: 0 6px 20px rgba(37, 211, 102, 0.5);
        }

        .btn-send:active:not(:disabled) {
            transform: scale(0.95);
        }

        .btn-send:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: scale(1);
        }

        .btn-attach,
        .btn-emoji,
        .btn-audio {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            flex-shrink: 0;
            backdrop-filter: blur(10px);
        }

        .btn-attach:hover:not(:disabled),
        .btn-emoji:hover:not(:disabled),
        .btn-audio:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--primary);
            transform: scale(1.08);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .btn-attach:active:not(:disabled),
        .btn-emoji:active:not(:disabled),
        .btn-audio:active:not(:disabled) {
            transform: scale(0.95);
        }

        .btn-attach:disabled,
        .btn-emoji:disabled,
        .btn-audio:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: scale(1);
        }

        .btn-audio.recording {
            background: rgba(239, 68, 68, 0.3);
            border-color: #ef4444;
            color: #ef4444;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Container de preview de áudio */
        .audio-preview-container {
            background: rgba(255, 255, 255, 0.1);
            border-left: 3px solid var(--primary);
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }

        .audio-preview-content {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
        }

        .audio-preview-icon {
            font-size: 1.5rem;
            color: var(--primary);
        }

        .audio-preview-info {
            flex: 1;
            min-width: 0;
        }

        .audio-preview-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .audio-preview-close {
            background: transparent;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-preview-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Container de gravação de áudio */
        .audio-recording-container {
            background: linear-gradient(90deg, rgba(239, 68, 68, 0.25) 0%, rgba(239, 68, 68, 0.15) 100%);
            border-left: 3px solid #ef4444;
            padding: 0.875rem 1.125rem;
            margin-bottom: 0.875rem;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
            backdrop-filter: blur(10px);
        }

        .audio-recording-content {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
        }

        .audio-recording-indicator {
            position: relative;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-recording-pulse {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.3);
            animation: recordingPulse 1.5s ease-in-out infinite;
        }

        @keyframes recordingPulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }

        .audio-recording-indicator i {
            position: relative;
            z-index: 1;
            font-size: 1.5rem;
            color: #ef4444;
        }

        .audio-recording-info {
            flex: 1;
        }

        .audio-recording-time {
            font-size: 1.25rem;
            font-weight: 700;
            color: #ef4444;
            font-variant-numeric: tabular-nums;
        }

        .audio-recording-text {
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .audio-recording-stop {
            background: #ef4444;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
        }

        .audio-recording-stop:hover {
            background: #dc2626;
            transform: scale(1.05);
        }

        /* Player de áudio nas mensagens */
        .message-audio-player {
            margin-top: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 0.75rem;
        }

        .message-audio-player audio {
            width: 100%;
            outline: none;
        }

        .file-preview-container,
        .audio-preview-container {
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.15) 0%, rgba(102, 126, 234, 0.05) 100%);
            border-left: 3px solid var(--primary);
            padding: 0.875rem 1.125rem;
            margin-bottom: 0.875rem;
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(10px);
        }

        .file-preview-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
        }

        .file-preview-content i {
            font-size: 1.5rem;
            color: var(--primary);
        }

        .file-preview-info {
            flex: 1;
            min-width: 0;
        }

        .file-preview-name {
            font-weight: 600;
            font-size: 0.85rem;
            margin-bottom: 0.25rem;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-preview-size {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .file-preview-close {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-primary);
            transition: all 0.2s ease;
            margin-left: 0.5rem;
        }

        .file-preview-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .emoji-picker {
            position: absolute;
            bottom: 80px;
            left: 1.75rem;
            right: 1.75rem;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(15, 23, 42, 0.95) 100%);
            backdrop-filter: blur(30px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 1.25rem;
            box-shadow: var(--shadow-xl);
            z-index: 1000;
            max-height: 320px;
            display: flex;
            flex-direction: column;
        }

        .emoji-categories {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--glass-border);
        }

        .emoji-category-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1.2rem;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .emoji-category-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .emoji-category-btn.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0.5rem;
            overflow-y: auto;
            max-height: 200px;
        }

        .emoji-item {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid transparent;
            border-radius: 12px;
            padding: 0.625rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1;
        }

        .emoji-item:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(102, 126, 234, 0.4);
            transform: scale(1.15) rotate(5deg);
            box-shadow: var(--shadow-sm);
        }

        body.light-mode .emoji-picker {
            background: rgba(255, 255, 255, 0.95);
            border-color: rgba(0, 0, 0, 0.1);
        }

        body.light-mode .emoji-category-btn {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.1);
        }

        body.light-mode .emoji-item {
            background: rgba(0, 0, 0, 0.03);
        }

        body.light-mode .emoji-item:hover {
            background: rgba(0, 0, 0, 0.08);
        }

        .empty-state {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: var(--text-secondary);
            text-align: center;
            padding: 3rem 2rem;
        }

        .empty-state i {
            font-size: 4.5rem;
            margin-bottom: 1.5rem;
            opacity: 0.4;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: blur(0.5px);
        }

        .empty-state h5 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .empty-state p {
            font-size: 0.95rem;
            opacity: 0.7;
        }

        .typing-indicator {
            display: flex;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 18px;
            max-width: 70px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        /* Scrollbar personalizada */
        .users-list::-webkit-scrollbar,
        .chat-messages::-webkit-scrollbar,
        .search-results::-webkit-scrollbar {
            width: 8px;
        }

        .users-list::-webkit-scrollbar-track,
        .chat-messages::-webkit-scrollbar-track,
        .search-results::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
        }

        .users-list::-webkit-scrollbar-thumb,
        .chat-messages::-webkit-scrollbar-thumb,
        .search-results::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--primary) 0%, var(--secondary) 100%);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .users-list::-webkit-scrollbar-thumb:hover,
        .chat-messages::-webkit-scrollbar-thumb:hover,
        .search-results::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, var(--primary-hover) 0%, var(--secondary) 100%);
        }

        /* Responsivo */
        @media (max-width: 768px) {
            .users-sidebar {
                width: 100%;
                position: absolute;
                z-index: 100;
                height: 100%;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }

            .users-sidebar.show {
                transform: translateX(0);
            }

            .message {
                max-width: 85%;
            }
        }

        /* Light mode */
        body.light-mode {
            background: linear-gradient(135deg, #eef2ff 0%, #f8fafc 60%, #ffffff 100%);
            color: #0f172a;
        }

        body.light-mode .chat-container {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(0, 0, 0, 0.1);
        }

        body.light-mode .users-sidebar {
            background: rgba(255, 255, 255, 0.95);
            border-color: rgba(0, 0, 0, 0.1);
        }

        body.light-mode .user-item {
            background: rgba(0, 0, 0, 0.03);
        }

        body.light-mode .user-item:hover {
            background: rgba(79, 70, 229, 0.1);
        }

        body.light-mode .message-content {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.1);
        }

        body.light-mode .message.sent .message-content {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
        }

        body.light-mode .chat-input {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.1);
            color: #0f172a;
        }

        body.light-mode .chat-input:focus {
            background: rgba(0, 0, 0, 0.08);
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <!-- Sidebar de usuários -->
        <div class="users-sidebar">
            <div class="sidebar-header">
                <h3><i class="fas fa-comments"></i> Chat Interno</h3>
            </div>
            <button class="btn-create-group" onclick="abrirModalCriarGrupo()">
                <i class="fas fa-plus"></i>
                Criar Grupo
            </button>
            <div class="users-search-container">
                <div class="users-search-wrapper">
                    <i class="fas fa-search users-search-icon"></i>
                    <input 
                        type="text" 
                        id="usersSearchInput" 
                        class="users-search-input" 
                        placeholder="Buscar usuários..."
                    >
                    <button class="users-search-clear" id="usersSearchClear" style="display: none;" title="Limpar busca">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            <div class="users-list" id="usersList">
                <div class="empty-state">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Carregando usuários...</p>
                </div>
            </div>
        </div>

        <!-- Área de chat -->
        <div class="chat-area">
            <div class="chat-header">
                <div class="chat-header-info">
                    <div class="chat-header-avatar" id="chatHeaderAvatar">?</div>
                    <div>
                        <div class="chat-header-name" id="chatHeaderName">Selecione um usuário</div>
                        <small class="text-muted" id="chatHeaderStatus">Para começar uma conversa</small>
                    </div>
                </div>
                <div class="chat-header-actions">
                    <div class="btn-group" id="grupoActionsGroup" style="display: none;">
                        <button class="btn btn-sm btn-icon" id="manageGroupButton" title="Gerenciar grupo" onclick="abrirModalGerenciarGrupo()">
                            <i class="fas fa-cog"></i>
                        </button>
                        <button class="btn btn-sm btn-icon" id="addParticipantButton" title="Adicionar participantes" onclick="abrirModalAdicionarParticipantes(selectedGrupoId)">
                            <i class="fas fa-user-plus"></i>
                        </button>
                    </div>
                    <button class="btn btn-sm btn-icon" id="searchButton" title="Buscar mensagens" style="display: none;">
                        <i class="fas fa-search"></i>
                    </button>
                <a href="portal.html" class="btn btn-sm btn-secondary">
                    <i class="fas fa-arrow-left"></i> Voltar
                </a>
                </div>
            </div>

            <!-- Modal de busca -->
            <div class="search-modal" id="searchModal" style="display: none;">
                <div class="search-modal-content">
                    <div class="search-modal-header">
                        <h5><i class="fas fa-search"></i> Buscar mensagens</h5>
                        <button class="search-modal-close" id="searchModalClose">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="search-modal-body">
                        <div class="search-input-wrapper">
                            <input type="text" id="searchInput" class="search-input" placeholder="Digite para buscar...">
                            <i class="fas fa-search search-input-icon"></i>
                        </div>
                        <div class="search-results" id="searchResults">
                            <div class="search-empty">
                                <i class="fas fa-search"></i>
                                <p>Digite para buscar mensagens</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="empty-state">
                    <i class="fas fa-comment-dots"></i>
                    <h5>Nenhuma conversa selecionada</h5>
                    <p>Selecione um usuário na lista para começar a conversar</p>
                </div>
            </div>

            <div class="chat-input-area">
                <div class="reply-preview-container" id="replyPreviewContainer" style="display: none;">
                    <div class="reply-preview-content">
                        <div class="reply-preview-author" id="replyPreviewAuthor"></div>
                        <div class="reply-preview-text" id="replyPreviewText"></div>
                    </div>
                    <button class="reply-preview-close" id="replyPreviewClose" title="Cancelar resposta">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="file-preview-container" id="filePreviewContainer" style="display: none;">
                    <div class="file-preview-content">
                        <i class="fas fa-file" id="filePreviewIcon"></i>
                        <div class="file-preview-info">
                            <div class="file-preview-name" id="filePreviewName"></div>
                            <div class="file-preview-size" id="filePreviewSize"></div>
                        </div>
                    </div>
                    <button class="file-preview-close" id="filePreviewClose" title="Remover arquivo">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="audio-preview-container" id="audioPreviewContainer" style="display: none;">
                    <div class="audio-preview-content">
                        <i class="fas fa-microphone audio-preview-icon"></i>
                        <div class="audio-preview-info">
                            <div class="audio-preview-title">Áudio gravado</div>
                            <audio id="audioPreviewPlayer" controls style="width: 100%; margin-top: 0.5rem;"></audio>
                        </div>
                    </div>
                    <button class="audio-preview-close" id="audioPreviewClose" title="Cancelar gravação">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="audio-recording-container" id="audioRecordingContainer" style="display: none;">
                    <div class="audio-recording-content">
                        <div class="audio-recording-indicator">
                            <div class="audio-recording-pulse"></div>
                            <i class="fas fa-microphone"></i>
                        </div>
                        <div class="audio-recording-info">
                            <div class="audio-recording-time" id="audioRecordingTime">00:00</div>
                            <div class="audio-recording-text">Gravando áudio...</div>
                        </div>
                    </div>
                    <button class="audio-recording-stop" id="audioRecordingStop" title="Parar gravação">
                        <i class="fas fa-stop"></i>
                    </button>
                </div>
                <div class="input-group">
                    <input 
                        type="file" 
                        id="fileInput" 
                        style="display: none;"
                        accept="*/*"
                    >
                    <button class="btn-attach" id="attachButton" title="Anexar arquivo" disabled>
                        <i class="fas fa-paperclip"></i>
                    </button>
                    <button class="btn-audio" id="audioButton" title="Gravar áudio" disabled>
                        <i class="fas fa-microphone"></i>
                    </button>
                    <button class="btn-emoji" id="emojiButton" title="Emojis" disabled>
                        <i class="fas fa-smile"></i>
                    </button>
                    <textarea 
                        class="chat-input" 
                        id="messageInput" 
                        placeholder="Digite sua mensagem..."
                        rows="1"
                        disabled
                    ></textarea>
                    <button class="btn-send" id="sendButton" disabled>
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
                <div class="emoji-picker" id="emojiPicker" style="display: none;">
                    <div class="emoji-categories">
                        <button class="emoji-category-btn active" data-category="smileys">😀</button>
                        <button class="emoji-category-btn" data-category="gestures">👋</button>
                        <button class="emoji-category-btn" data-category="hearts">❤️</button>
                        <button class="emoji-category-btn" data-category="objects">🎉</button>
                        <button class="emoji-category-btn" data-category="symbols">✅</button>
                    </div>
                    <div class="emoji-grid" id="emojiGrid">
                        <!-- Emojis serão inseridos aqui via JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let currentUserId = null;
        let currentUserData = null;
        let selectedUserId = null;
        let supabaseClient = null;
        let messagesInterval = null;
        let usersInterval = null;
        let statusInterval = null;
        let lastMessageId = null;
        let replyingToMessage = null;
        let messagesCache = new Map(); // Cache de mensagens para buscar respostas
        let selectedFile = null; // Arquivo selecionado para envio
        let mediaRecorder = null; // MediaRecorder para gravar áudio
        let audioChunks = []; // Chunks de áudio gravados
        let audioBlob = null; // Blob do áudio gravado
        let recordingTimer = null; // Timer para mostrar duração da gravação
        let recordingStartTime = null; // Tempo de início da gravação
        let allUsersData = []; // Armazenar todos os usuários para filtro
        let selectedGrupoId = null; // ID do grupo selecionado (null se for conversa individual)
        let isGrupoMode = false; // Flag para indicar se está em modo grupo
        let gruposData = []; // Armazenar dados dos grupos
        let grupoSelecionadoParaAdicionar = null; // Grupo selecionado para adicionar participantes
        let userStatusMap = new Map(); // Mapa de status dos usuários (userId -> { online: boolean, lastSeen: Date })
        let statusUpdateInterval = null; // Intervalo para atualizar status
        let columnsAvailable = { entregue: false, visualizada: false }; // Flag para rastrear se as colunas existem
        let columnsChecked = false; // Flag para evitar verificar múltiplas vezes

        // Inicializar Supabase
        async function initSupabase() {
            try {
                const cfg = await fetch('/api/supabase-config').then(r => r.json());
                supabaseClient = window.supabase.createClient(cfg.supabaseUrl, cfg.supabaseAnonKey);
                
                // Obter usuário atual
                const { data: { session } } = await supabaseClient.auth.getSession();
                if (session?.user) {
                    currentUserId = session.user.id;
                    await loadCurrentUserData();
                } else {
                    alert('Você precisa estar logado para usar o chat. Redirecionando...');
                    window.location.href = 'login.html';
                    return;
                }
            } catch (error) {
                console.error('Erro ao inicializar Supabase:', error);
                alert('Erro ao conectar ao sistema. Tente novamente.');
            }
        }

        // Carregar dados do usuário atual
        async function loadCurrentUserData() {
            try {
                const { data: profile } = await supabaseClient
                    .from('user_profiles')
                    .select('id, nome, email, departamento')
                    .eq('id', currentUserId)
                    .single();

                if (profile) {
                    currentUserData = profile;
                    // Verificar e tentar executar migration das colunas de vistos se necessário
                    // Usar silent=true para evitar logs desnecessários na primeira verificação
                    await checkColumnsAvailability(true);
                    await tryExecuteMigration();
                    await loadUsers();
                }
            } catch (error) {
                console.error('Erro ao carregar perfil:', error);
            }
        }

        // Verificar se as colunas entregue e visualizada existem
        // Em vez de fazer SELECT (que gera erro 400), vamos tentar usar as colunas em operações reais
        // e tratar os erros quando ocorrerem
        async function checkColumnsAvailability(silent = false, force = false) {
            // Se já foi verificado e não é forçado, retornar cache
            if (columnsChecked && !force) {
                return columnsAvailable;
            }
            
            // Por padrão, assumir que as colunas não existem
            // Elas serão marcadas como existentes quando forem usadas com sucesso
            columnsAvailable = { entregue: false, visualizada: false };
            columnsChecked = true;
            
            if (!silent) {
                console.log('📊 Status das colunas (assumindo que não existem até serem usadas):', columnsAvailable);
            }
            
            return columnsAvailable;
        }
        
        // Função auxiliar para marcar colunas como disponíveis quando usadas com sucesso
        function markColumnAsAvailable(columnName) {
            if (columnName === 'entregue') {
                columnsAvailable.entregue = true;
            } else if (columnName === 'visualizada') {
                columnsAvailable.visualizada = true;
            }
        }
        
        // Função auxiliar para marcar colunas como indisponíveis quando falharem
        function markColumnAsUnavailable(columnName) {
            if (columnName === 'entregue') {
                columnsAvailable.entregue = false;
            } else if (columnName === 'visualizada') {
                columnsAvailable.visualizada = false;
            }
        }

        // Tentar executar migration das colunas entregue e visualizada
        async function tryExecuteMigration() {
            try {
                // Verificar se as colunas já existem
                const cols = await checkColumnsAvailability();
                
                if (cols.entregue && cols.visualizada) {
                    // Colunas já existem
                    console.log('✅ Colunas entregue e visualizada já existem');
                    return;
                }

                // Se não existirem, verificar se o usuário é admin antes de tentar executar
                const { data: { session } } = await supabaseClient.auth.getSession();
                if (!session || !session.access_token) {
                    console.warn('⚠️ Usuário não autenticado. Não é possível executar migration automaticamente.');
                    return;
                }

                // Verificar se é admin
                const { data: userProfile } = await supabaseClient
                    .from('user_profiles')
                    .select('role')
                    .eq('id', currentUserId)
                    .maybeSingle();

                const isAdmin = userProfile?.role === 'admin';
                if (!isAdmin) {
                    console.warn('⚠️ Apenas administradores podem executar migration. Execute manualmente no Supabase Dashboard.');
                    return;
                }

                // Se não existirem, tentar executar migration via API
                console.log('🔧 Colunas entregue/visualizada não existem. Tentando executar migration...');
                const response = await fetch('/api/chat-interno/adicionar-colunas', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${session.access_token}`
                    },
                    credentials: 'include'
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('✅ Migration executada com sucesso!');
                        // Aguardar um pouco e verificar novamente se as colunas foram criadas (forçar verificação)
                        setTimeout(async () => {
                            await checkColumnsAvailability(false, true);
                        }, 1000);
                    } else {
                        console.warn('⚠️ Migration não foi executada:', result.message);
                    }
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    if (response.status === 401) {
                        console.warn('⚠️ Não autenticado. Não é possível executar migration automaticamente.');
                    } else if (response.status === 403) {
                        console.warn('⚠️ Apenas administradores podem executar migration. Execute manualmente no Supabase Dashboard.');
                    } else {
                        console.warn('⚠️ Não foi possível executar migration automaticamente. Execute manualmente no Supabase Dashboard.');
                    }
                }
            } catch (error) {
                console.warn('⚠️ Erro ao tentar executar migration:', error);
                console.log('📋 Para adicionar as colunas manualmente, execute no Supabase Dashboard:');
                console.log(`
ALTER TABLE chat_mensagens ADD COLUMN IF NOT EXISTS entregue BOOLEAN DEFAULT false;
ALTER TABLE chat_mensagens ADD COLUMN IF NOT EXISTS visualizada BOOLEAN DEFAULT false;
                `);
            }
        }

        // ========== SISTEMA DE STATUS ONLINE/OFFLINE ==========
        
        // Atualizar status do usuário atual (heartbeat) - marca como online na plataforma
        async function updateCurrentUserStatus() {
            if (!currentUserId || !supabaseClient) return;
            
            try {
                // Chamar função do banco para marcar usuário como online
                const { error } = await supabaseClient.rpc('mark_user_online', {
                    p_user_id: currentUserId
                });
                
                if (error) {
                    console.warn('Erro ao marcar usuário como online:', error);
                }
                
                // Marcar usuário atual como online no mapa local
                userStatusMap.set(currentUserId, {
                    online: true,
                    lastSeen: new Date()
                });
            } catch (error) {
                console.warn('Erro ao atualizar status:', error);
            }
        }
        
        // Verificar status de outros usuários baseado na tabela de presença
        async function checkUsersStatus() {
            if (!supabaseClient || !allUsersData || allUsersData.length === 0) return;
            
            try {
                const userIds = allUsersData.map(u => u.id);
                if (userIds.length === 0) return;
                
                // Buscar status de presença na tabela user_presence
                const { data: presenceData, error } = await supabaseClient
                    .from('user_presence')
                    .select('user_id, is_online, last_seen')
                    .in('user_id', userIds);
                
                if (error) {
                    console.warn('Erro ao verificar status:', error);
                    return;
                }
                
                // Criar mapa de presença
                const presenceMap = new Map();
                if (presenceData) {
                    presenceData.forEach(p => {
                        presenceMap.set(p.user_id, {
                            online: p.is_online,
                            lastSeen: p.last_seen ? new Date(p.last_seen) : null
                        });
                    });
                }
                
                // Atualizar mapa de status
                userIds.forEach(userId => {
                    // Usuário atual sempre está online
                    if (userId === currentUserId) {
                        userStatusMap.set(userId, {
                            online: true,
                            lastSeen: new Date()
                        });
                        return;
                    }
                    
                    const presence = presenceMap.get(userId);
                    if (presence) {
                        // Verificar se ainda está online (última atividade há menos de 5 minutos)
                        const OFFLINE_THRESHOLD = 5 * 60 * 1000; // 5 minutos
                        const now = new Date();
                        const lastSeen = presence.lastSeen ? new Date(presence.lastSeen) : null;
                        
                        let isOnline = presence.online;
                        
                        // Se está marcado como online mas não teve atividade recente, considerar offline
                        if (isOnline && lastSeen) {
                            const timeSinceLastSeen = now - lastSeen;
                            if (timeSinceLastSeen > OFFLINE_THRESHOLD) {
                                isOnline = false;
                            }
                        }
                        
                        userStatusMap.set(userId, {
                            online: isOnline,
                            lastSeen: lastSeen
                        });
                    } else {
                        // Se não tem registro de presença, considerar offline
                        userStatusMap.set(userId, {
                            online: false,
                            lastSeen: null
                        });
                    }
                });
                
                // Atualizar interface
                updateUsersStatusInUI();
                
            } catch (error) {
                console.warn('Erro ao verificar status dos usuários:', error);
            }
        }
        
        // Atualizar status na interface
        function updateUsersStatusInUI() {
            // Atualizar status dots na lista de usuários
            document.querySelectorAll('.user-item[data-user-id]').forEach(item => {
                const userId = item.getAttribute('data-user-id');
                
                if (!userId) return;
                
                const status = userStatusMap.get(userId);
                const statusDot = item.querySelector('.status-dot');
                
                if (statusDot) {
                    // Se não há status ou status.online é true, remover classe offline
                    if (!status || status.online !== false) {
                        statusDot.classList.remove('offline');
                    } else {
                        statusDot.classList.add('offline');
                    }
                }
            });
        }
        
        // Marcar usuário como offline
        async function markUserOffline() {
            if (!currentUserId || !supabaseClient) return;
            
            try {
                // Chamar função do banco para marcar usuário como offline
                const { error } = await supabaseClient.rpc('mark_user_offline', {
                    p_user_id: currentUserId
                });
                
                if (error) {
                    console.warn('Erro ao marcar usuário como offline:', error);
                }
            } catch (error) {
                console.warn('Erro ao marcar usuário como offline:', error);
            }
        }
        
        // Iniciar sistema de status
        function startStatusSystem() {
            // Atualizar status do usuário atual imediatamente
            updateCurrentUserStatus();
            
            // Atualizar status do usuário atual a cada 30 segundos (heartbeat)
            setInterval(() => {
                updateCurrentUserStatus();
            }, 30000);
            
            // Verificar status de outros usuários a cada 1 minuto
            checkUsersStatus();
            setInterval(() => {
                checkUsersStatus();
            }, 60000);
        }

        // Carregar lista de usuários
        async function loadUsers() {
            try {
                // Buscar todos os usuários
                const { data: users, error } = await supabaseClient
                    .from('user_profiles')
                    .select('id, nome, email, departamento, active')
                    .eq('active', true)
                    .order('nome');

                if (error) throw error;

                // Buscar IDs de motoristas na tabela motoristas
                const { data: motoristas, error: motoristasError } = await supabaseClient
                    .from('motoristas')
                    .select('auth_user_id')
                    .not('auth_user_id', 'is', null);

                if (motoristasError) {
                    console.warn('⚠️ Erro ao buscar motoristas:', motoristasError);
                }

                // Criar Set com IDs de motoristas para busca rápida
                const motoristaIds = new Set();
                if (motoristas && motoristas.length > 0) {
                    motoristas.forEach(m => {
                        if (m.auth_user_id) {
                            motoristaIds.add(m.auth_user_id);
                        }
                    });
                }

                // Filtrar apenas usuários administrativos (excluir motoristas)
                const usuariosAdministrativos = (users || []).filter(usuario => {
                    // Excluir se for um motorista
                    if (motoristaIds.has(usuario.id)) {
                        return false;
                    }
                    return true;
                });

                const usersListEl = document.getElementById('usersList');
                if (!usuariosAdministrativos || usuariosAdministrativos.length === 0) {
                    console.warn('⚠️ Nenhum usuário administrativo encontrado!');
                    console.warn('📋 Verificando possíveis causas:');
                    console.warn('   - Todos os usuários podem estar marcados como active=false');
                    console.warn('   - Todos os usuários podem ser motoristas');
                    console.warn('   - Pode não haver usuários cadastrados em user_profiles');
                    
                    usersListEl.innerHTML = `
                        <div class="empty-state">
                            <i class="fas fa-users"></i>
                            <p>Nenhum usuário encontrado</p>
                            <small style="margin-top: 0.5rem; opacity: 0.7;">
                                Verifique se há usuários administrativos cadastrados em Settings
                            </small>
                        </div>
                    `;
                    return;
                }

                // Buscar últimas mensagens e contadores de não lidas (apenas entre usuários administrativos)
                let lastMessages = [];
                let unreadCounts = [];
                
                if (usuariosAdministrativos.length > 0) {
                    const userIds = usuariosAdministrativos.map(u => u.id);
                    
                    // Buscar últimas mensagens apenas entre usuários administrativos
                    const { data: messagesData, error: messagesError } = await supabaseClient
                    .from('chat_mensagens')
                    .select('id, remetente_id, destinatario_id, mensagem, created_at')
                    .or(`remetente_id.in.(${userIds.join(',')}),destinatario_id.in.(${userIds.join(',')})`)
                    .order('created_at', { ascending: false })
                    .limit(100);

                    if (!messagesError && messagesData) {
                        lastMessages = messagesData;
                    }
                    
                    // Buscar contadores de não lidas apenas de usuários administrativos
                    const { data: unreadData, error: unreadError } = await supabaseClient
                    .from('chat_mensagens')
                    .select('remetente_id')
                    .eq('destinatario_id', currentUserId)
                        .in('remetente_id', userIds) // Apenas mensagens de usuários administrativos
                    .eq('lida', false)
                    .limit(1000);
                    
                    if (!unreadError && unreadData) {
                        unreadCounts = unreadData;
                    }
                }

                const unreadMap = new Map();
                (unreadCounts || []).forEach(msg => {
                    const senderId = msg.remetente_id;
                    unreadMap.set(senderId, (unreadMap.get(senderId) || 0) + 1);
                });

                // Agrupar últimas mensagens por conversa
                const lastMessageMap = new Map();
                (lastMessages || []).forEach(msg => {
                    const otherUserId = msg.remetente_id === currentUserId ? msg.destinatario_id : msg.remetente_id;
                    if (!lastMessageMap.has(otherUserId)) {
                        lastMessageMap.set(otherUserId, msg);
                    } else {
                        // Manter a mensagem mais recente
                        const existing = lastMessageMap.get(otherUserId);
                        if (new Date(msg.created_at) > new Date(existing.created_at)) {
                        lastMessageMap.set(otherUserId, msg);
                        }
                    }
                });

                // Preparar lista de usuários com informações de conversa
                const usersWithConversation = usuariosAdministrativos
                    .filter(u => u.id !== currentUserId)
                    .map(user => {
                        const lastMsg = lastMessageMap.get(user.id);
                        const unread = unreadMap.get(user.id) || 0;
                        return {
                            ...user,
                            lastMessage: lastMsg,
                            unreadCount: unread,
                            lastMessageDate: lastMsg ? new Date(lastMsg.created_at) : new Date(0)
                        };
                    });

                // Ordenar: primeiro não lidas (por data), depois lidas (por data)
                usersWithConversation.sort((a, b) => {
                    // Se ambos têm não lidas, ordenar por data (mais recente primeiro)
                    if (a.unreadCount > 0 && b.unreadCount > 0) {
                        return b.lastMessageDate - a.lastMessageDate;
                    }
                    // Se só A tem não lidas, A vem primeiro
                    if (a.unreadCount > 0 && b.unreadCount === 0) {
                        return -1;
                    }
                    // Se só B tem não lidas, B vem primeiro
                    if (a.unreadCount === 0 && b.unreadCount > 0) {
                        return 1;
                    }
                    // Se nenhum tem não lidas, ordenar por data (mais recente primeiro)
                    return b.lastMessageDate - a.lastMessageDate;
                });

                // Armazenar dados para filtro
                allUsersData = usersWithConversation;

                // Log informativo
                const totalUsuarios = (users || []).length;
                const totalMotoristas = motoristaIds.size;
                const totalAdministrativos = usuariosAdministrativos.length;
                const totalComConversa = usersWithConversation.length;
                console.log(`✅ Chat Interno: ${totalAdministrativos} usuário(s) administrativo(s) carregado(s) (${totalMotoristas} motorista(s) excluído(s) de ${totalUsuarios} total)`);
                console.log(`📊 Usuários com conversas: ${totalComConversa}, Total para exibir: ${usersWithConversation.length}`);
                
                // Debug: listar IDs dos usuários
                if (usuariosAdministrativos.length > 0) {
                    console.log('👥 IDs dos usuários administrativos:', usuariosAdministrativos.map(u => ({ id: u.id, nome: u.nome, email: u.email })));
                } else {
                    console.warn('⚠️ Nenhum usuário administrativo encontrado! Verifique se há usuários com active=true em user_profiles');
                }

                // Carregar grupos do usuário
                await loadGrupos();

                // Renderizar usuários e grupos
                renderUsersAndGrupos(usersWithConversation, gruposData);
                
                // Verificar status dos usuários após renderizar
                await checkUsersStatus();

            } catch (error) {
                // Verificar se é erro de coluna não existente
                if (error.message && error.message.includes('does not exist')) {
                    console.error('❌ Erro: Colunas não existem na tabela chat_mensagens.');
                    console.error('📋 Execute a migração SQL primeiro. Veja INSTRUCOES-CHAT-INTERNO.md');
                    document.getElementById('usersList').innerHTML = '<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><p>Erro: Tabela não configurada</p><small>Execute a migração SQL primeiro. Veja INSTRUCOES-CHAT-INTERNO.md</small></div>';
                } else {
                    console.error('Erro ao carregar usuários:', error);
                    document.getElementById('usersList').innerHTML = '<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><p>Erro ao carregar usuários</p></div>';
                }
            }
        }

        // Renderizar lista de usuários e grupos
        function renderUsersAndGrupos(users, grupos) {
            const usersListEl = document.getElementById('usersList');
            
            const allItems = [];
            
            // Adicionar grupos primeiro
            if (grupos && grupos.length > 0) {
                grupos.forEach(grupo => {
                    allItems.push({
                        type: 'grupo',
                        id: grupo.id,
                        nome: grupo.nome,
                        descricao: grupo.descricao,
                        lastMessage: grupo.lastMessage,
                        unreadCount: grupo.unreadCount,
                        lastMessageDate: grupo.lastMessageDate,
                        participantes: grupo.participantes || []
                    });
                });
            }
            
            // Adicionar usuários
            if (users && users.length > 0) {
                users.forEach(user => {
                    allItems.push({
                        type: 'user',
                        id: user.id,
                        nome: user.nome,
                        email: user.email,
                        departamento: user.departamento,
                        lastMessage: user.lastMessage,
                        unreadCount: user.unreadCount,
                        lastMessageDate: user.lastMessageDate
                    });
                });
            }
            
            // Ordenar: primeiro não lidas (por data), depois lidas (por data)
            allItems.sort((a, b) => {
                if (a.unreadCount > 0 && b.unreadCount > 0) {
                    return b.lastMessageDate - a.lastMessageDate;
                }
                if (a.unreadCount > 0 && b.unreadCount === 0) {
                    return -1;
                }
                if (a.unreadCount === 0 && b.unreadCount > 0) {
                    return 1;
                }
                return b.lastMessageDate - a.lastMessageDate;
            });
            
            if (allItems.length === 0) {
                usersListEl.innerHTML = '<div class="empty-state"><i class="fas fa-user-slash"></i><p>Nenhuma conversa encontrada</p></div>';
                return;
            }

            usersListEl.innerHTML = allItems
                .map(item => {
                    if (item.type === 'grupo') {
                        const initials = item.nome.substring(0, 2).toUpperCase();
                        const lastMsg = item.lastMessage;
                        const unread = item.unreadCount;
                        const isSelected = isGrupoMode && selectedGrupoId === item.id;
                        
                        return `
                            <div class="user-item group-item ${isSelected ? 'active' : ''}" onclick="selectGrupo('${item.id}')">
                                <div style="display: flex; align-items: center; width: 100%;">
                                    <div class="user-avatar" style="position: relative;">
                                        ${initials}
                                        <div class="group-icon">
                                            <i class="fas fa-users"></i>
                                        </div>
                                    </div>
                                    <div class="user-info" style="flex: 1; min-width: 0;">
                                        <div class="user-name" style="display: flex; align-items: center; justify-content: space-between;">
                                            <span>${escapeHtml(item.nome)}</span>
                                            ${lastMsg ? `<span style="font-size: 0.7rem; opacity: 0.6; margin-left: 0.5rem;">${new Date(lastMsg.created_at).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}</span>` : ''}
                                        </div>
                                        <div class="user-status">
                                            <span style="font-size: 0.75rem; opacity: 0.7;">${item.participantes.length} participante(s)</span>
                                        </div>
                                        ${lastMsg ? `<small style="opacity: ${unread > 0 ? 1 : 0.7}; font-size: 0.8rem; margin-top: 0.25rem; display: block; font-weight: ${unread > 0 ? '600' : '400'};">${escapeHtml(lastMsg.mensagem.substring(0, 30))}${lastMsg.mensagem.length > 30 ? '...' : ''}</small>` : ''}
                                    </div>
                                    ${unread > 0 ? `<span class="unread-badge" style="background: #ef4444; color: white; border-radius: 12px; padding: 0.25rem 0.5rem; font-size: 0.75rem; font-weight: 700; margin-left: 0.5rem; min-width: 20px; text-align: center;">${unread > 99 ? '99+' : unread}</span>` : ''}
                                </div>
                            </div>
                        `;
                    } else {
                        const initials = (item.nome || item.email || '?').split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
                        const lastMsg = item.lastMessage;
                        const unread = item.unreadCount;
                        const isSelected = !isGrupoMode && selectedUserId === item.id;
                        
                        // Verificar status do usuário (online por padrão se não houver status ainda)
                        const userStatus = userStatusMap.get(item.id);
                        const isOffline = userStatus && userStatus.online === false;
                        const statusClass = isOffline ? 'offline' : '';
                        
                        return `
                            <div class="user-item ${isSelected ? 'active' : ''}" onclick="selectUser('${item.id}')" data-user-id="${item.id}">
                                <div style="display: flex; align-items: center; width: 100%;">
                                    <div class="user-avatar">${initials}</div>
                                    <div class="user-info" style="flex: 1; min-width: 0;">
                                        <div class="user-name" style="display: flex; align-items: center; justify-content: space-between;">
                                            <span>${escapeHtml(item.nome || item.email || 'Usuário')}</span>
                                            ${lastMsg ? `<span style="font-size: 0.7rem; opacity: 0.6; margin-left: 0.5rem;">${new Date(lastMsg.created_at).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}</span>` : ''}
                                        </div>
                                        <div class="user-status">
                                            <span class="status-dot ${statusClass}"></span>
                                            ${escapeHtml(item.departamento || 'Sem departamento')}
                                        </div>
                                        ${lastMsg ? `<small style="opacity: ${unread > 0 ? 1 : 0.7}; font-size: 0.8rem; margin-top: 0.25rem; display: block; font-weight: ${unread > 0 ? '600' : '400'};">${escapeHtml(lastMsg.mensagem.substring(0, 30))}${lastMsg.mensagem.length > 30 ? '...' : ''}</small>` : ''}
                                    </div>
                                    ${unread > 0 ? `<span class="unread-badge" style="background: #ef4444; color: white; border-radius: 12px; padding: 0.25rem 0.5rem; font-size: 0.75rem; font-weight: 700; margin-left: 0.5rem; min-width: 20px; text-align: center;">${unread > 99 ? '99+' : unread}</span>` : ''}
                                </div>
                            </div>
                        `;
                    }
                    }).join('');
        }

        // Renderizar lista de usuários (mantida para compatibilidade)
        function renderUsers(users) {
            renderUsersAndGrupos(users, gruposData);
        }

        // Filtrar usuários
        function filterUsers(searchQuery) {
            if (!searchQuery || searchQuery.trim() === '') {
                renderUsers(allUsersData);
                return;
            }

            const query = searchQuery.toLowerCase().trim();
            const filtered = allUsersData.filter(user => {
                const nome = (user.nome || '').toLowerCase();
                const email = (user.email || '').toLowerCase();
                const departamento = (user.departamento || '').toLowerCase();
                
                return nome.includes(query) || 
                       email.includes(query) || 
                       departamento.includes(query);
            });

            renderUsers(filtered);
        }

        // Inicializar busca de usuários
        function initUsersSearch() {
            const searchInput = document.getElementById('usersSearchInput');
            const searchClear = document.getElementById('usersSearchClear');

            if (!searchInput || !searchClear) return;

            // Buscar ao digitar
            let searchTimeout;
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                const query = e.target.value.trim();
                
                // Mostrar/ocultar botão de limpar
                if (query.length > 0) {
                    searchClear.style.display = 'flex';
                } else {
                    searchClear.style.display = 'none';
                }

                searchTimeout = setTimeout(() => {
                    filterUsers(query);
                }, 200); // Debounce de 200ms
            });

            // Limpar busca
            searchClear.addEventListener('click', () => {
                searchInput.value = '';
                searchClear.style.display = 'none';
                filterUsers('');
                searchInput.focus();
            });

            // Limpar com ESC
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    searchInput.value = '';
                    searchClear.style.display = 'none';
                    filterUsers('');
                }
            });
        }

        // Selecionar usuário para conversar
        async function selectUser(userId) {
            selectedUserId = userId;
            selectedGrupoId = null;
            isGrupoMode = false;
            
            // Limpar resposta ao trocar de usuário
            cancelReply();
            messagesCache.clear();
            
            // Atualizar UI
            document.querySelectorAll('.user-item').forEach(item => {
                item.classList.remove('active');
                if (item.getAttribute('onclick')?.includes(`'${userId}'`)) {
                    item.classList.add('active');
                }
            });

            // Carregar dados do usuário selecionado
            const { data: user } = await supabaseClient
                .from('user_profiles')
                .select('id, nome, email, departamento')
                .eq('id', userId)
                .single();

            if (user) {
                const initials = (user.nome || user.email || '?').split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
                document.getElementById('chatHeaderAvatar').textContent = initials;
                document.getElementById('chatHeaderName').textContent = user.nome || user.email || 'Usuário';
                document.getElementById('chatHeaderStatus').textContent = user.departamento || 'Online';
                
                document.getElementById('messageInput').disabled = false;
                document.getElementById('sendButton').disabled = false;
                document.getElementById('emojiButton').disabled = false;
                document.getElementById('attachButton').disabled = false;
                document.getElementById('audioButton').disabled = false;
                
                // Mostrar botão de busca e ocultar botões de grupo
                document.getElementById('searchButton').style.display = 'block';
                const grupoActionsGroup = document.getElementById('grupoActionsGroup');
                if (grupoActionsGroup) {
                    grupoActionsGroup.style.display = 'none';
                }
            }

            await loadMessages();
            startMessagesPolling();
        }

        // ========== FUNÇÕES DE GRUPOS ==========

        // Carregar grupos do usuário
        async function loadGrupos() {
            try {
                // Buscar grupos onde o usuário é participante
                const { data: participantes, error: participantesError } = await supabaseClient
                    .from('chat_grupo_participantes')
                    .select('grupo_id')
                    .eq('usuario_id', currentUserId);

                if (participantesError) throw participantesError;

                if (!participantes || participantes.length === 0) {
                    gruposData = [];
                    return;
                }

                const grupoIds = participantes.map(p => p.grupo_id);

                // Buscar dados dos grupos
                const { data: grupos, error: gruposError } = await supabaseClient
                    .from('chat_grupos')
                    .select('*')
                    .in('id', grupoIds)
                    .order('created_at', { ascending: false });

                if (gruposError) throw gruposError;

                // Buscar últimas mensagens dos grupos
                const { data: mensagensGrupos, error: mensagensError } = await supabaseClient
                    .from('chat_mensagens')
                    .select('*')
                    .in('grupo_id', grupoIds)
                    .order('created_at', { ascending: false })
                    .limit(100);

                // Buscar contadores de não lidas dos grupos
                const { data: naoLidas, error: naoLidasError } = await supabaseClient
                    .from('chat_mensagens')
                    .select('grupo_id')
                    .in('grupo_id', grupoIds)
                    .eq('lida', false)
                    .neq('remetente_id', currentUserId);

                // Buscar participantes de cada grupo
                const { data: todosParticipantes, error: participantesDataError } = await supabaseClient
                    .from('chat_grupo_participantes')
                    .select('grupo_id, usuario_id')
                    .in('grupo_id', grupoIds);

                // Agrupar participantes por grupo
                const participantesPorGrupo = new Map();
                if (todosParticipantes) {
                    todosParticipantes.forEach(p => {
                        if (!participantesPorGrupo.has(p.grupo_id)) {
                            participantesPorGrupo.set(p.grupo_id, []);
                        }
                        participantesPorGrupo.get(p.grupo_id).push(p.usuario_id);
                    });
                }

                // Agrupar mensagens por grupo
                const lastMessageMap = new Map();
                if (mensagensGrupos) {
                    mensagensGrupos.forEach(msg => {
                        if (!lastMessageMap.has(msg.grupo_id)) {
                            lastMessageMap.set(msg.grupo_id, msg);
                        } else {
                            const existing = lastMessageMap.get(msg.grupo_id);
                            if (new Date(msg.created_at) > new Date(existing.created_at)) {
                                lastMessageMap.set(msg.grupo_id, msg);
                            }
                        }
                    });
                }

                // Contar não lidas por grupo
                const unreadMap = new Map();
                if (naoLidas) {
                    naoLidas.forEach(msg => {
                        const grupoId = msg.grupo_id;
                        unreadMap.set(grupoId, (unreadMap.get(grupoId) || 0) + 1);
                    });
                }

                // Preparar dados dos grupos
                gruposData = (grupos || []).map(grupo => {
                    const lastMsg = lastMessageMap.get(grupo.id);
                    const unread = unreadMap.get(grupo.id) || 0;
                    const participantes = participantesPorGrupo.get(grupo.id) || [];

                    return {
                        ...grupo,
                        lastMessage: lastMsg,
                        unreadCount: unread,
                        lastMessageDate: lastMsg ? new Date(lastMsg.created_at) : new Date(0),
                        participantes: participantes
                    };
                });

                console.log(`✅ ${gruposData.length} grupo(s) carregado(s)`);

            } catch (error) {
                console.error('Erro ao carregar grupos:', error);
                gruposData = [];
            }
        }

        // Selecionar grupo
        async function selectGrupo(grupoId) {
            selectedGrupoId = grupoId;
            selectedUserId = null;
            isGrupoMode = true;

            // Atualizar header
            const grupo = gruposData.find(g => g.id === grupoId);
            if (grupo) {
                document.getElementById('chatHeaderName').textContent = grupo.nome;
                document.getElementById('chatHeaderStatus').textContent = `${grupo.participantes.length} participante(s)`;
                const initials = grupo.nome.substring(0, 2).toUpperCase();
                const avatarEl = document.getElementById('chatHeaderAvatar');
                avatarEl.innerHTML = initials;
                avatarEl.style.position = 'relative';
                avatarEl.innerHTML = `${initials}<i class="fas fa-users" style="font-size: 0.6rem; position: absolute; bottom: -2px; right: -2px;"></i>`;
            }

            // Verificar se o usuário é criador ou admin do grupo
            const permissao = await verificarPermissaoGrupo(grupoId);
            
            // Mostrar/ocultar botões de gerenciamento
            const grupoActionsGroup = document.getElementById('grupoActionsGroup');
            if (grupoActionsGroup) {
                grupoActionsGroup.style.display = permissao.podeGerenciar ? 'flex' : 'none';
            }
            
            // Habilitar botões
            document.getElementById('searchButton').style.display = 'inline-block';
            document.getElementById('emojiButton').disabled = false;
            document.getElementById('attachButton').disabled = false;
            document.getElementById('audioButton').disabled = false;
            document.getElementById('messageInput').disabled = false;
            document.getElementById('sendButton').disabled = false;

            // Carregar mensagens do grupo
            await loadMessagesGrupo(grupoId);

            // Marcar mensagens como lidas
            await markMessagesAsReadGrupo(grupoId);

            // Atualizar lista
            await loadUsers();
            startMessagesPolling();
        }

        // Carregar mensagens do grupo
        async function loadMessagesGrupo(grupoId) {
            try {
                const { data: messages, error } = await supabaseClient
                    .from('chat_mensagens')
                    .select('*')
                    .eq('grupo_id', grupoId)
                    .order('created_at', { ascending: true })
                    .limit(100);

                if (error) throw error;

                const messagesEl = document.getElementById('chatMessages');
                messagesEl.innerHTML = '';

                if (!messages || messages.length === 0) {
                    messagesEl.innerHTML = '<div class="empty-state"><i class="fas fa-comment-dots"></i><h5>Nenhuma mensagem</h5><p>Seja o primeiro a enviar uma mensagem!</p></div>';
                    return;
                }

                let lastDate = null;
                messages.forEach(msg => {
                    const msgDate = new Date(msg.created_at).toDateString();
                    if (lastDate !== msgDate) {
                        addDateSeparator(msgDate);
                        lastDate = msgDate;
                    }
                    addMessageToUI(msg, false);
                    messagesCache.set(msg.id, msg);
                });

                scrollToBottom();
                lastMessageId = messages[messages.length - 1]?.id;

            } catch (error) {
                console.error('Erro ao carregar mensagens do grupo:', error);
            }
        }

        // Marcar mensagens do grupo como lidas
        async function markMessagesAsReadGrupo(grupoId) {
            try {
                await supabaseClient
                    .from('chat_mensagens')
                    .update({ lida: true })
                    .eq('grupo_id', grupoId)
                    .neq('remetente_id', currentUserId)
                    .eq('lida', false);
            } catch (error) {
                console.error('Erro ao marcar mensagens do grupo como lidas:', error);
            }
        }

        // Abrir modal de criar grupo
        async function abrirModalCriarGrupo() {
            const modal = new bootstrap.Modal(document.getElementById('modalCriarGrupo'));
            
            // Carregar lista de usuários para seleção
            await carregarParticipantesParaModal();
            
            modal.show();
        }

        // Carregar participantes para modal
        async function carregarParticipantesParaModal() {
            try {
                const { data: users, error } = await supabaseClient
                    .from('user_profiles')
                    .select('id, nome, email, departamento')
                    .eq('active', true)
                    .neq('id', currentUserId)
                    .order('nome');

                if (error) throw error;

                // Buscar IDs de motoristas
                const { data: motoristas } = await supabaseClient
                    .from('motoristas')
                    .select('auth_user_id')
                    .not('auth_user_id', 'is', null);

                const motoristaIds = new Set();
                if (motoristas) {
                    motoristas.forEach(m => {
                        if (m.auth_user_id) motoristaIds.add(m.auth_user_id);
                    });
                }

                const usuariosAdministrativos = (users || []).filter(u => !motoristaIds.has(u.id));

                const participantesList = document.getElementById('participantesList');
                participantesList.innerHTML = usuariosAdministrativos
                    .map(user => {
                        const initials = (user.nome || user.email || '?').split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
                        return `
                            <div class="participante-item">
                                <input type="checkbox" value="${user.id}" id="participante_${user.id}">
                                <div class="participante-avatar">${initials}</div>
                                <div class="participante-info">
                                    <div class="participante-nome">${escapeHtml(user.nome || user.email)}</div>
                                    <div class="participante-departamento">${escapeHtml(user.departamento || 'Sem departamento')}</div>
                                </div>
                            </div>
                        `;
                    }).join('');

            } catch (error) {
                console.error('Erro ao carregar participantes:', error);
                document.getElementById('participantesList').innerHTML = '<div class="text-center text-danger">Erro ao carregar usuários</div>';
            }
        }

        // Criar grupo
        async function criarGrupo() {
            const nome = document.getElementById('grupoNome').value.trim();
            const descricao = document.getElementById('grupoDescricao').value.trim();
            const checkboxes = document.querySelectorAll('#participantesList input[type="checkbox"]:checked');

            if (!nome) {
                alert('Por favor, informe o nome do grupo.');
                return;
            }

            if (checkboxes.length === 0) {
                alert('Por favor, selecione pelo menos um participante.');
                return;
            }

            try {
                // Criar grupo
                const { data: grupo, error: grupoError } = await supabaseClient
                    .from('chat_grupos')
                    .insert([{
                        nome: nome,
                        descricao: descricao || null,
                        criado_por: currentUserId
                    }])
                    .select()
                    .single();

                if (grupoError) throw grupoError;

                // Adicionar participantes (incluindo o criador)
                const participantes = [
                    { grupo_id: grupo.id, usuario_id: currentUserId, admin: true, adicionado_por: currentUserId },
                    ...Array.from(checkboxes).map(cb => ({
                        grupo_id: grupo.id,
                        usuario_id: cb.value,
                        admin: false,
                        adicionado_por: currentUserId
                    }))
                ];

                const { error: participantesError } = await supabaseClient
                    .from('chat_grupo_participantes')
                    .insert(participantes);

                if (participantesError) throw participantesError;

                // Fechar modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('modalCriarGrupo'));
                modal.hide();

                // Limpar campos
                document.getElementById('grupoNome').value = '';
                document.getElementById('grupoDescricao').value = '';

                // Recarregar lista
                await loadUsers();

                // Selecionar o grupo criado
                await selectGrupo(grupo.id);

                alert('Grupo criado com sucesso!');

            } catch (error) {
                console.error('Erro ao criar grupo:', error);
                alert('Erro ao criar grupo. Tente novamente.');
            }
        }

        // Abrir modal para adicionar participantes
        async function abrirModalAdicionarParticipantes(grupoId) {
            // Verificar permissão
            const permissao = await verificarPermissaoGrupo(grupoId);
            if (!permissao.podeGerenciar) {
                alert('Apenas o criador ou administradores do grupo podem adicionar participantes.');
                return;
            }
            
            grupoSelecionadoParaAdicionar = grupoId;
            const modal = new bootstrap.Modal(document.getElementById('modalAdicionarParticipantes'));
            await carregarParticipantesParaAdicionar(grupoId);
            modal.show();
        }

        // Carregar participantes para adicionar (excluindo os que já estão no grupo)
        async function carregarParticipantesParaAdicionar(grupoId) {
            try {
                // Buscar participantes atuais do grupo
                const { data: participantesAtuais, error: participantesError } = await supabaseClient
                    .from('chat_grupo_participantes')
                    .select('usuario_id')
                    .eq('grupo_id', grupoId);

                if (participantesError) throw participantesError;

                const participantesIds = new Set((participantesAtuais || []).map(p => p.usuario_id));

                // Buscar todos os usuários
                const { data: users, error } = await supabaseClient
                    .from('user_profiles')
                    .select('id, nome, email, departamento')
                    .eq('active', true)
                    .neq('id', currentUserId)
                    .order('nome');

                if (error) throw error;

                // Filtrar motoristas
                const { data: motoristas } = await supabaseClient
                    .from('motoristas')
                    .select('auth_user_id')
                    .not('auth_user_id', 'is', null);

                const motoristaIds = new Set();
                if (motoristas) {
                    motoristas.forEach(m => {
                        if (m.auth_user_id) motoristaIds.add(m.auth_user_id);
                    });
                }

                // Filtrar usuários que não estão no grupo e não são motoristas
                const usuariosDisponiveis = (users || []).filter(u => 
                    !participantesIds.has(u.id) && !motoristaIds.has(u.id)
                );

                const participantesList = document.getElementById('participantesAdicionarList');
                participantesList.innerHTML = usuariosDisponiveis
                    .map(user => {
                        const initials = (user.nome || user.email || '?').split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
                        return `
                            <div class="participante-item">
                                <input type="checkbox" value="${user.id}" id="participante_add_${user.id}">
                                <div class="participante-avatar">${initials}</div>
                                <div class="participante-info">
                                    <div class="participante-nome">${escapeHtml(user.nome || user.email)}</div>
                                    <div class="participante-departamento">${escapeHtml(user.departamento || 'Sem departamento')}</div>
                                </div>
                            </div>
                        `;
                    }).join('');

                if (usuariosDisponiveis.length === 0) {
                    participantesList.innerHTML = '<div class="text-center text-muted">Todos os usuários já estão no grupo</div>';
                }

            } catch (error) {
                console.error('Erro ao carregar participantes:', error);
                document.getElementById('participantesAdicionarList').innerHTML = '<div class="text-center text-danger">Erro ao carregar usuários</div>';
            }
        }

        // Adicionar participantes ao grupo
        async function adicionarParticipantes() {
            if (!grupoSelecionadoParaAdicionar) return;

            // Verificar permissão
            const permissao = await verificarPermissaoGrupo(grupoSelecionadoParaAdicionar);
            if (!permissao.podeGerenciar) {
                alert('Apenas o criador ou administradores do grupo podem adicionar participantes.');
                return;
            }

            const checkboxes = document.querySelectorAll('#participantesAdicionarList input[type="checkbox"]:checked');

            if (checkboxes.length === 0) {
                alert('Por favor, selecione pelo menos um participante.');
                return;
            }

            try {
                const participantes = Array.from(checkboxes).map(cb => ({
                    grupo_id: grupoSelecionadoParaAdicionar,
                    usuario_id: cb.value,
                    admin: false,
                    adicionado_por: currentUserId
                }));

                const { error } = await supabaseClient
                    .from('chat_grupo_participantes')
                    .insert(participantes);

                if (error) throw error;

                // Fechar modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('modalAdicionarParticipantes'));
                modal.hide();

                // Recarregar grupos e mensagens
                await loadGrupos();
                await loadUsers();
                if (isGrupoMode && selectedGrupoId === grupoSelecionadoParaAdicionar) {
                    await loadMessagesGrupo(selectedGrupoId);
                }

                alert('Participantes adicionados com sucesso!');

            } catch (error) {
                console.error('Erro ao adicionar participantes:', error);
                alert('Erro ao adicionar participantes. Tente novamente.');
            }
        }

        // Abrir modal de gerenciar grupo
        window.abrirModalGerenciarGrupo = async function() {
            if (!selectedGrupoId) return;
            
            // Verificar permissão
            const permissao = await verificarPermissaoGrupo(selectedGrupoId);
            if (!permissao.podeGerenciar) {
                alert('Apenas o criador ou administradores do grupo podem gerenciá-lo.');
                return;
            }
            
            const modal = new bootstrap.Modal(document.getElementById('modalGerenciarGrupo'));
            await carregarParticipantesParaGerenciar(selectedGrupoId);
            modal.show();
        };

        // Carregar participantes para gerenciar
        async function carregarParticipantesParaGerenciar(grupoId) {
            try {
                // Buscar participantes do grupo com informações dos usuários
                const { data: participantes, error: participantesError } = await supabaseClient
                    .from('chat_grupo_participantes')
                    .select('usuario_id, admin, adicionado_por')
                    .eq('grupo_id', grupoId);

                if (participantesError) throw participantesError;

                if (!participantes || participantes.length === 0) {
                    document.getElementById('participantesGerenciarList').innerHTML = '<div class="text-center text-muted">Nenhum participante encontrado</div>';
                    return;
                }

                // Buscar informações dos usuários
                const userIds = participantes.map(p => p.usuario_id);
                const { data: users, error: usersError } = await supabaseClient
                    .from('user_profiles')
                    .select('id, nome, email, departamento')
                    .in('id', userIds);

                if (usersError) throw usersError;

                // Buscar dados do grupo para verificar criador e admin
                const grupo = gruposData.find(g => g.id === grupoId);
                const isCriador = grupo && grupo.criado_por === currentUserId;
                
                // Verificar se o usuário atual é admin
                const participanteAtual = participantes.find(p => p.usuario_id === currentUserId);
                const isAdmin = participanteAtual?.admin === true;
                const podeGerenciar = isCriador || isAdmin;

                // Mostrar/ocultar botão de excluir grupo (apenas criador)
                const btnExcluirGrupo = document.getElementById('btnExcluirGrupo');
                if (btnExcluirGrupo) {
                    btnExcluirGrupo.style.display = isCriador ? 'block' : 'none';
                }

                // Criar mapa de usuários para busca rápida
                const usersMap = new Map();
                (users || []).forEach(user => {
                    usersMap.set(user.id, user);
                });

                const participantesList = document.getElementById('participantesGerenciarList');
                participantesList.innerHTML = participantes
                    .map(p => {
                        const user = usersMap.get(p.usuario_id);
                        if (!user) return '';
                        
                        const initials = (user.nome || user.email || '?').split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
                        const isCurrentUser = p.usuario_id === currentUserId;
                        const isCriadorParticipante = grupo && grupo.criado_por === p.usuario_id;
                        
                        return `
                            <div class="participante-item" style="display: flex; align-items: center; justify-content: space-between;">
                                <div style="display: flex; align-items: center; flex: 1;">
                                    <div class="participante-avatar">${initials}</div>
                                    <div class="participante-info" style="flex: 1;">
                                        <div class="participante-nome">
                                            ${escapeHtml(user.nome || user.email)}
                                            ${isCriadorParticipante ? ' <span style="color: var(--primary); font-size: 0.8rem;">(Criador)</span>' : ''}
                                            ${p.admin ? ' <span style="color: var(--accent); font-size: 0.8rem;">(Admin)</span>' : ''}
                                        </div>
                                        <div class="participante-departamento">${escapeHtml(user.departamento || 'Sem departamento')}</div>
                                    </div>
                                </div>
                                <div style="display: flex; gap: 5px;">
                                    ${isCriador && !isCurrentUser && !isCriadorParticipante ? `
                                        ${!p.admin ? `
                                            <button class="btn btn-sm btn-success" onclick="promoverAdmin('${p.usuario_id}', '${escapeHtml(user.nome || user.email)}')" title="Promover a administrador">
                                                <i class="fas fa-user-shield"></i>
                                            </button>
                                        ` : `
                                            <button class="btn btn-sm btn-warning" onclick="removerAdmin('${p.usuario_id}', '${escapeHtml(user.nome || user.email)}')" title="Remover administrador">
                                                <i class="fas fa-user-shield"></i>
                                            </button>
                                        `}
                                    ` : ''}
                                    ${podeGerenciar && !isCurrentUser && !isCriadorParticipante ? `
                                        <button class="btn btn-sm btn-danger" onclick="removerParticipante('${p.usuario_id}', '${escapeHtml(user.nome || user.email)}')" title="Remover participante">
                                            <i class="fas fa-user-minus"></i>
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                        `;
                    }).join('');

            } catch (error) {
                console.error('Erro ao carregar participantes para gerenciar:', error);
                document.getElementById('participantesGerenciarList').innerHTML = '<div class="text-center text-danger">Erro ao carregar participantes</div>';
            }
        }

        // Verificar se o usuário atual é criador ou admin do grupo
        async function verificarPermissaoGrupo(grupoId) {
            const grupo = gruposData.find(g => g.id === grupoId);
            if (!grupo) return { isCriador: false, isAdmin: false };
            
            const isCriador = grupo.criado_por === currentUserId;
            
            // Buscar se o usuário atual é admin
            const { data: participante, error } = await supabaseClient
                .from('chat_grupo_participantes')
                .select('admin')
                .eq('grupo_id', grupoId)
                .eq('usuario_id', currentUserId)
                .maybeSingle();
            
            const isAdmin = participante?.admin === true;
            
            return { isCriador, isAdmin, podeGerenciar: isCriador || isAdmin };
        }

        // Remover participante do grupo
        window.removerParticipante = async function(usuarioId, usuarioNome) {
            if (!selectedGrupoId) return;
            
            const permissao = await verificarPermissaoGrupo(selectedGrupoId);
            if (!permissao.podeGerenciar) {
                alert('Apenas o criador ou administradores do grupo podem remover participantes.');
                return;
            }
            
            if (!confirm(`Tem certeza que deseja remover ${usuarioNome} do grupo?`)) {
                return;
            }
            
            try {
                const { error } = await supabaseClient
                    .from('chat_grupo_participantes')
                    .delete()
                    .eq('grupo_id', selectedGrupoId)
                    .eq('usuario_id', usuarioId);

                if (error) throw error;

                // Recarregar grupos e atualizar interface
                await loadGrupos();
                await loadUsers();
                
                // Atualizar modal se estiver aberto
                const modal = bootstrap.Modal.getInstance(document.getElementById('modalGerenciarGrupo'));
                if (modal && modal._isShown) {
                    await carregarParticipantesParaGerenciar(selectedGrupoId);
                }
                
                // Atualizar header se ainda estiver no grupo
                if (isGrupoMode && selectedGrupoId === selectedGrupoId) {
                    const grupoAtualizado = gruposData.find(g => g.id === selectedGrupoId);
                    if (grupoAtualizado) {
                        document.getElementById('chatHeaderStatus').textContent = `${grupoAtualizado.participantes.length} participante(s)`;
                    }
                }

                alert('Participante removido com sucesso!');

            } catch (error) {
                console.error('Erro ao remover participante:', error);
                alert('Erro ao remover participante. Tente novamente.');
            }
        };

        // Promover usuário a administrador (apenas criador)
        window.promoverAdmin = async function(usuarioId, usuarioNome) {
            if (!selectedGrupoId) return;
            
            const grupo = gruposData.find(g => g.id === selectedGrupoId);
            if (!grupo || grupo.criado_por !== currentUserId) {
                alert('Apenas o criador do grupo pode promover administradores.');
                return;
            }
            
            if (!confirm(`Tem certeza que deseja promover ${usuarioNome} a administrador do grupo?`)) {
                return;
            }
            
            try {
                const { error } = await supabaseClient
                    .from('chat_grupo_participantes')
                    .update({ admin: true })
                    .eq('grupo_id', selectedGrupoId)
                    .eq('usuario_id', usuarioId);

                if (error) throw error;

                // Recarregar participantes
                await carregarParticipantesParaGerenciar(selectedGrupoId);
                await loadGrupos();
                
                alert(`${usuarioNome} foi promovido a administrador do grupo!`);

            } catch (error) {
                console.error('Erro ao promover administrador:', error);
                alert('Erro ao promover administrador. Tente novamente.');
            }
        };

        // Remover administrador (apenas criador)
        window.removerAdmin = async function(usuarioId, usuarioNome) {
            if (!selectedGrupoId) return;
            
            const grupo = gruposData.find(g => g.id === selectedGrupoId);
            if (!grupo || grupo.criado_por !== currentUserId) {
                alert('Apenas o criador do grupo pode remover administradores.');
                return;
            }
            
            if (!confirm(`Tem certeza que deseja remover ${usuarioNome} da função de administrador?`)) {
                return;
            }
            
            try {
                const { error } = await supabaseClient
                    .from('chat_grupo_participantes')
                    .update({ admin: false })
                    .eq('grupo_id', selectedGrupoId)
                    .eq('usuario_id', usuarioId);

                if (error) throw error;

                // Recarregar participantes
                await carregarParticipantesParaGerenciar(selectedGrupoId);
                await loadGrupos();
                
                alert(`${usuarioNome} não é mais administrador do grupo.`);

            } catch (error) {
                console.error('Erro ao remover administrador:', error);
                alert('Erro ao remover administrador. Tente novamente.');
            }
        };

        // Confirmar exclusão do grupo
        window.confirmarExcluirGrupo = function() {
            if (!selectedGrupoId) return;
            
            const grupo = gruposData.find(g => g.id === selectedGrupoId);
            if (!grupo) return;
            
            const grupoNome = grupo.nome || 'este grupo';
            
            if (!confirm(`⚠️ ATENÇÃO: Tem certeza que deseja excluir o grupo "${grupoNome}"?\n\nEsta ação não pode ser desfeita e todas as mensagens do grupo serão perdidas.`)) {
                return;
            }
            
            // Segunda confirmação
            if (!confirm(`Confirma a exclusão do grupo "${grupoNome}"?`)) {
                return;
            }
            
            excluirGrupo();
        };

        // Excluir grupo
        async function excluirGrupo() {
            if (!selectedGrupoId) return;
            
            const grupo = gruposData.find(g => g.id === selectedGrupoId);
            if (!grupo || grupo.criado_por !== currentUserId) {
                alert('Apenas o criador do grupo pode excluí-lo.');
                return;
            }
            
            try {
                // Excluir grupo (as mensagens e participantes serão excluídos automaticamente por CASCADE)
                const { error } = await supabaseClient
                    .from('chat_grupos')
                    .delete()
                    .eq('id', selectedGrupoId);

                if (error) throw error;

                // Fechar modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('modalGerenciarGrupo'));
                if (modal) {
                    modal.hide();
                }

                // Limpar seleção
                selectedGrupoId = null;
                isGrupoMode = false;
                
                // Ocultar botões de grupo
                const grupoActionsGroup = document.getElementById('grupoActionsGroup');
                if (grupoActionsGroup) {
                    grupoActionsGroup.style.display = 'none';
                }

                // Resetar interface
                document.getElementById('chatHeaderName').textContent = 'Selecione um usuário';
                document.getElementById('chatHeaderStatus').textContent = 'Para começar uma conversa';
                document.getElementById('chatHeaderAvatar').textContent = '?';
                document.getElementById('chatMessages').innerHTML = '<div class="empty-state"><i class="fas fa-comment-dots"></i><h5>Nenhuma conversa selecionada</h5><p>Selecione um usuário na lista para começar a conversar</p></div>';
                
                // Desabilitar botões
                document.getElementById('searchButton').style.display = 'none';
                document.getElementById('emojiButton').disabled = true;
                document.getElementById('attachButton').disabled = true;
                document.getElementById('audioButton').disabled = true;
                document.getElementById('messageInput').disabled = true;
                document.getElementById('sendButton').disabled = true;

                // Recarregar lista
                await loadUsers();

                alert('Grupo excluído com sucesso!');

            } catch (error) {
                console.error('Erro ao excluir grupo:', error);
                alert('Erro ao excluir grupo. Tente novamente.');
            }
        }

        // Carregar mensagens
        async function loadMessages() {
            if (!selectedUserId && !selectedGrupoId) return;
            
            if (isGrupoMode && selectedGrupoId) {
                await loadMessagesGrupo(selectedGrupoId);
                return;
            }
            
            if (!selectedUserId) return;

            try {
                const { data: messages, error } = await supabaseClient
                    .from('chat_mensagens')
                    .select('*')
                    .or(`and(remetente_id.eq.${currentUserId},destinatario_id.eq.${selectedUserId}),and(remetente_id.eq.${selectedUserId},destinatario_id.eq.${currentUserId})`)
                    .order('created_at', { ascending: true })
                    .limit(1000);

                if (error) throw error;

                const messagesEl = document.getElementById('chatMessages');
                messagesEl.innerHTML = '';

                if (!messages || messages.length === 0) {
                    messagesEl.innerHTML = '<div class="empty-state"><i class="fas fa-comment"></i><p>Nenhuma mensagem ainda</p><small>Seja o primeiro a enviar uma mensagem!</small></div>';
                    return;
                }

                messages.forEach(msg => {
                    addMessageToUI(msg, false);
                });

                // Marcar mensagens como lidas
                await markMessagesAsRead();

                scrollToBottom();
                lastMessageId = messages[messages.length - 1]?.id || null;

            } catch (error) {
                // Verificar se é erro de coluna não existente
                if (error.message && error.message.includes('does not exist')) {
                    console.error('❌ Erro: Colunas não existem na tabela chat_mensagens.');
                    console.error('📋 Execute a migração SQL primeiro. Veja INSTRUCOES-CHAT-INTERNO.md');
                    const messagesEl = document.getElementById('chatMessages');
                    messagesEl.innerHTML = '<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><p>Erro: Tabela não configurada</p><small>Execute a migração SQL primeiro. Veja INSTRUCOES-CHAT-INTERNO.md</small></div>';
                } else {
                    console.error('Erro ao carregar mensagens:', error);
                }
            }
        }

        // Adicionar mensagem na UI
        async function addMessageToUI(message, isNew = true) {
            const messagesEl = document.getElementById('chatMessages');
            
            // Verificar se a mensagem já existe no DOM ou no cache para evitar duplicatas
            const existingMessage = messagesEl.querySelector(`[data-message-id="${message.id}"]`);
            if (existingMessage) {
                // Mensagem já existe no DOM, apenas atualizar o cache e retornar
                messagesCache.set(message.id, message);
                return;
            }
            
            // Verificar se já está no cache (proteção adicional contra duplicatas)
            if (messagesCache.has(message.id)) {
                // Mensagem já está no cache, não adicionar novamente
                return;
            }
            
            // Remover empty state se existir
            const emptyState = messagesEl.querySelector('.empty-state');
            if (emptyState) emptyState.remove();

            // Armazenar mensagem no cache
            messagesCache.set(message.id, message);

            const isSent = message.remetente_id === currentUserId;
            const senderName = isSent ? (currentUserData?.nome || 'Você') : (message.remetente_nome || 'Usuário');
            const initials = senderName.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
            
            const messageDate = new Date(message.created_at);
            const time = messageDate.toLocaleTimeString('pt-BR', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            // Verificar se precisa adicionar separador de data
            const messageDateStr = messageDate.toDateString();
            const lastDateSeparator = messagesEl.querySelector('.message-date-separator:last-of-type');
            let needsDateSeparator = false;
            
            if (!lastDateSeparator) {
                // Primeira mensagem, sempre adicionar separador
                needsDateSeparator = true;
            } else {
                const lastDate = lastDateSeparator.dataset.date;
                if (lastDate !== messageDateStr) {
                    needsDateSeparator = true;
                }
            }
            
            // Adicionar separador de data se necessário
            if (needsDateSeparator) {
                const dateSeparator = document.createElement('div');
                dateSeparator.className = 'message-date-separator';
                dateSeparator.dataset.date = messageDateStr;
                
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                let dateText = '';
                if (messageDate.toDateString() === today.toDateString()) {
                    dateText = 'Hoje';
                } else if (messageDate.toDateString() === yesterday.toDateString()) {
                    dateText = 'Ontem';
                } else {
                    dateText = messageDate.toLocaleDateString('pt-BR', {
                        weekday: 'long',
                        day: 'numeric',
                        month: 'long',
                        year: messageDate.getFullYear() !== today.getFullYear() ? 'numeric' : undefined
                    });
                    // Capitalizar primeira letra
                    dateText = dateText.charAt(0).toUpperCase() + dateText.slice(1);
                }
                
                dateSeparator.innerHTML = `<div class="message-date-separator-text">${dateText}</div>`;
                messagesEl.appendChild(dateSeparator);
            }

            // Buscar mensagem original se for resposta
            let replyPreview = '';
            if (message.reply_to_id) {
                const originalMessage = messagesCache.get(message.reply_to_id);
                if (originalMessage) {
                    const originalSenderName = originalMessage.remetente_id === currentUserId 
                        ? (currentUserData?.nome || 'Você') 
                        : (originalMessage.remetente_nome || 'Usuário');
                    const originalText = originalMessage.mensagem.length > 50 
                        ? originalMessage.mensagem.substring(0, 50) + '...' 
                        : originalMessage.mensagem;
                    replyPreview = `
                        <div class="message-reply-preview">
                            <div class="message-reply-preview-author">${escapeHtml(originalSenderName)}</div>
                            <div class="message-reply-preview-text">${escapeHtml(originalText)}</div>
                        </div>
                    `;
                }
            }

            // Gerar HTML do arquivo se houver
            let fileHtml = '';
            
            // Detectar tipo de arquivo (fora do if para estar acessível em todo o escopo)
            const isImage = message.arquivo_url && message.arquivo_tipo && message.arquivo_tipo.startsWith('image/');
            const isPdf = message.arquivo_url && (
                message.arquivo_tipo === 'application/pdf' || 
                (message.arquivo_nome && message.arquivo_nome.toLowerCase().endsWith('.pdf'))
            );
            
            // Detecção robusta de áudio
            const isAudio = message.arquivo_url && (
                (message.arquivo_tipo && (
                    message.arquivo_tipo.startsWith('audio/') ||
                    message.arquivo_tipo === 'audio/webm'
                )) ||
                (message.arquivo_nome && (
                    message.arquivo_nome.toLowerCase().startsWith('audio_') ||
                    message.arquivo_nome.toLowerCase().endsWith('.webm') ||
                    message.arquivo_nome.toLowerCase().endsWith('.mp3') ||
                    message.arquivo_nome.toLowerCase().endsWith('.wav') ||
                    message.arquivo_nome.toLowerCase().endsWith('.ogg') ||
                    message.arquivo_nome.toLowerCase().endsWith('.m4a')
                ))
            );
            
            // Debug
            if (isAudio) {
                console.log('🎤 Áudio detectado:', {
                    url: message.arquivo_url,
                    nome: message.arquivo_nome,
                    tipo: message.arquivo_tipo
                });
            }
            
            if (message.arquivo_url) {
                
                if (isImage) {
                    // Imagem: exibir no chat e permitir visualização em modal
                    const safeFileName = escapeHtml(message.arquivo_nome || 'Imagem');
                    // Usar encodeURIComponent para URLs e escapeHtml para o nome
                    const encodedUrl = encodeURIComponent(message.arquivo_url);
                    fileHtml = `
                        <div class="message-file">
                            <img src="${message.arquivo_url}" alt="${safeFileName}" 
                                 class="message-file-image" 
                                 data-image-url="${message.arquivo_url}"
                                 data-image-name="${safeFileName}"
                                 title="Clique para visualizar em tamanho maior"
                                 style="cursor: pointer;">
                        </div>
                    `;
                } else if (isPdf) {
                    // PDF: exibir preview com iframe e botão de download
                    fileHtml = `
                        <div class="message-file">
                            <div class="message-file-document">
                                <i class="fas fa-file-pdf message-file-icon"></i>
                                <div class="message-file-info">
                                    <div class="message-file-name">${escapeHtml(message.arquivo_nome || 'Documento PDF')}</div>
                                    <div class="message-file-size">${message.arquivo_tamanho ? formatFileSize(message.arquivo_tamanho) : ''}</div>
                                </div>
                            </div>
                            <div class="message-file-pdf-preview">
                                <iframe src="${message.arquivo_url}#toolbar=0" type="application/pdf"></iframe>
                                <div class="message-file-pdf-actions">
                                    <button class="btn-pdf-download" onclick="downloadFile('${message.arquivo_url}', '${escapeHtml(message.arquivo_nome || 'documento.pdf')}')">
                                        <i class="fas fa-download"></i> Baixar PDF
                                    </button>
                                    <a href="${message.arquivo_url}" target="_blank" class="btn-pdf-download" style="text-decoration: none;">
                                        <i class="fas fa-external-link-alt"></i> Abrir em nova aba
                                    </a>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (isAudio) {
                    // Áudio: exibir player
                    fileHtml = `
                        <div class="message-file">
                            <div class="message-audio-player">
                                <audio controls data-audio-url="${message.arquivo_url}" data-audio-type="${message.arquivo_tipo || 'audio/webm'}">
                                    Seu navegador não suporta o elemento de áudio.
                                </audio>
                                <div style="margin-top: 0.5rem; font-size: 0.85rem; opacity: 0.8;">
                                    <i class="fas fa-microphone"></i> ${escapeHtml(message.arquivo_nome || 'Áudio')}
                                    ${message.arquivo_tamanho ? ` • ${formatFileSize(message.arquivo_tamanho)}` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    // Outros arquivos: exibir ícone e permitir download
                    const fileIcon = getFileIcon(message.arquivo_tipo, message.arquivo_nome);
                    fileHtml = `
                        <div class="message-file">
                            <div class="message-file-document" onclick="downloadFile('${message.arquivo_url}', '${escapeHtml(message.arquivo_nome || 'arquivo')}')" style="cursor: pointer;">
                                <i class="${fileIcon} message-file-icon"></i>
                                <div class="message-file-info">
                                    <div class="message-file-name">${escapeHtml(message.arquivo_nome || 'Arquivo')}</div>
                                    <div class="message-file-size">${message.arquivo_tamanho ? formatFileSize(message.arquivo_tamanho) : ''}</div>
                                </div>
                                <i class="fas fa-download message-file-download"></i>
                            </div>
                        </div>
                    `;
                }
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
            messageDiv.dataset.messageId = message.id;
            messageDiv.innerHTML = `
                <div class="message-avatar">${initials}</div>
                <div class="message-content">
                    ${replyPreview}
                    ${fileHtml}
                    ${message.mensagem ? `<div class="message-text">${escapeHtml(message.mensagem)}</div>` : ''}
                    <div class="message-footer">
                        <div class="message-time">${time}</div>
                        ${isSent ? `
                            <div class="message-status" data-message-id="${message.id}">
                                ${(message.visualizada !== undefined && message.visualizada) ? `
                                    <i class="fas fa-check-double message-status-icon message-status-read"></i>
                                    <i class="fas fa-check-double message-status-icon message-status-read"></i>
                                ` : (message.entregue !== undefined && message.entregue) ? `
                                    <i class="fas fa-check-double message-status-icon message-status-delivered"></i>
                                    <i class="fas fa-check-double message-status-icon message-status-delivered"></i>
                                ` : `
                                    <i class="fas fa-check message-status-icon message-status-sent"></i>
                                `}
                            </div>
                        ` : ''}
                    </div>
                </div>
                <div class="message-actions">
                    <button class="btn-reply" onclick="startReply('${message.id}')" title="Responder">
                        <i class="fas fa-reply"></i>
                        <span>Responder</span>
                    </button>
                </div>
            `;

            messagesEl.appendChild(messageDiv);
            
            // Adicionar event listener para imagens (modal) e gerar signed URL se necessário
            const imageElement = messageDiv.querySelector('.message-file-image');
            if (imageElement && imageElement.dataset.imageUrl) {
                const imageUrl = imageElement.dataset.imageUrl;
                
                // Gerar signed URL se for do Supabase Storage (assíncrono, não bloqueia)
                if (imageUrl.includes('supabase.co/storage/v1/object/public/chat-files/')) {
                    const urlParts = imageUrl.split('/object/public/chat-files/');
                    if (urlParts.length > 1) {
                        const filePath = urlParts[1];
                        supabaseClient.storage
                            .from('chat-files')
                            .createSignedUrl(filePath, 3600)
                            .then(({ data, error }) => {
                                if (!error && data?.signedUrl) {
                                    imageElement.src = data.signedUrl;
                                }
                            })
                            .catch(err => {
                                console.warn('⚠️ Erro ao gerar signed URL para imagem:', err);
                            });
                    }
                }
                
                // Adicionar listener para abrir modal
                imageElement.addEventListener('click', function(e) {
                    e.stopPropagation(); // Evitar propagação do evento
                    const imageUrl = this.dataset.imageUrl;
                    const imageName = this.dataset.imageName || 'Imagem';
                    // Buscar messageId do elemento pai
                    const messageDiv = this.closest('[data-message-id]');
                    const messageId = messageDiv ? messageDiv.dataset.messageId : null;
                    openImageModal(imageUrl, imageName, messageId);
                });
            }

            // Gerar URL assinada para áudio se necessário
            // Usar setTimeout para garantir que o DOM esteja totalmente renderizado
            // Capturar variáveis necessárias
            const audioUrlForSetup = message.arquivo_url;
            const audioTypeForSetup = message.arquivo_tipo || 'audio/webm';
            const isAudioForSetup = isAudio;
            
            setTimeout(() => {
                const audioElement = messageDiv.querySelector('audio[data-audio-url]');
                if (!audioElement) {
                    // Tentar encontrar novamente caso não tenha sido encontrado
                    const audioElements = messageDiv.querySelectorAll('audio');
                    if (audioElements.length > 0 && isAudioForSetup && audioUrlForSetup) {
                        console.warn('⚠️ Elemento audio encontrado sem data-audio-url, tentando configurar...');
                        const firstAudio = audioElements[0];
                        firstAudio.setAttribute('data-audio-url', audioUrlForSetup);
                        firstAudio.setAttribute('data-audio-type', audioTypeForSetup);
                        // Continuar com a configuração
                        setupAudioPlayer(firstAudio, audioUrlForSetup, audioTypeForSetup);
                    }
                    return;
                }
                
                if (audioElement && audioElement.dataset.audioUrl) {
                    setupAudioPlayer(audioElement, audioElement.dataset.audioUrl, audioElement.dataset.audioType || 'audio/webm');
                }
            }, 100); // Pequeno delay para garantir que o DOM esteja renderizado
            
            // Função auxiliar para configurar o player de áudio
            function setupAudioPlayer(audioElement, audioUrl, audioType) {
                console.log('🎵 Configurando player de áudio:', { audioUrl, audioType });
                
                // Limpar conteúdo anterior do audio
                audioElement.innerHTML = '';
                
                // Se é URL do Supabase Storage, gerar URL assinada e converter para blob
                if (audioUrl.includes('supabase.co/storage/v1/object/public/chat-files/')) {
                    (async () => {
                        try {
                            const urlParts = audioUrl.split('/object/public/chat-files/');
                            if (urlParts.length > 1) {
                                const filePath = urlParts[1];
                                console.log('🔐 Gerando URL assinada para:', filePath);
                                
                                const { data, error } = await supabaseClient.storage
                                    .from('chat-files')
                                    .createSignedUrl(filePath, 3600);
                                
                                if (!error && data?.signedUrl) {
                                    console.log('✅ URL assinada gerada com sucesso');
                                    
                                    // Baixar o áudio e converter para blob para contornar CSP
                                    try {
                                        console.log('📥 Baixando áudio...');
                                        const response = await fetch(data.signedUrl);
                                        
                                        if (!response.ok) {
                                            throw new Error(`HTTP error! status: ${response.status}`);
                                        }
                                        
                                        const blob = await response.blob();
                                        const blobUrl = URL.createObjectURL(blob);
                                        
                                        console.log('✅ Áudio convertido para blob URL');
                                        
                                        // Usar blob URL no player (permitido pela CSP)
                                        audioElement.src = blobUrl;
                                        audioElement.type = audioType;
                                        
                                        // Adicionar source como fallback
                                        const source = document.createElement('source');
                                        source.src = blobUrl;
                                        source.type = audioType;
                                        audioElement.appendChild(source);
                                        
                                        // Limpar blob URL quando o áudio for descartado
                                        audioElement.addEventListener('loadstart', () => {
                                            // Manter o blob URL ativo
                                        });
                                        
                                        // Forçar carregamento
                                        audioElement.load();
                                    } catch (fetchError) {
                                        console.error('❌ Erro ao baixar áudio:', fetchError);
                                        // Tentar usar URL assinada diretamente como último recurso
                                        audioElement.src = data.signedUrl;
                                        audioElement.type = audioType;
                                        audioElement.load();
                                    }
                                } else {
                                    console.warn('⚠️ Erro ao gerar URL assinada:', error);
                                    // Fallback: tentar baixar da URL pública
                                    try {
                                        const response = await fetch(audioUrl);
                                        if (response.ok) {
                                            const blob = await response.blob();
                                            const blobUrl = URL.createObjectURL(blob);
                                            audioElement.src = blobUrl;
                                            audioElement.type = audioType;
                                            audioElement.load();
                                        } else {
                                            throw new Error('Não foi possível baixar o áudio');
                                        }
                                    } catch (fallbackError) {
                                        console.error('❌ Erro no fallback:', fallbackError);
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('❌ Erro ao gerar URL assinada para áudio:', error);
                            // Tentar baixar da URL pública e converter para blob
                            try {
                                const response = await fetch(audioUrl);
                                if (response.ok) {
                                    const blob = await response.blob();
                                    const blobUrl = URL.createObjectURL(blob);
                                    audioElement.src = blobUrl;
                                    audioElement.type = audioType;
                                    audioElement.load();
                                }
                            } catch (fetchError) {
                                console.error('❌ Erro ao baixar áudio da URL pública:', fetchError);
                            }
                        }
                    })();
                } else {
                    // URL não é do Supabase, tentar baixar e converter para blob se necessário
                    (async () => {
                        try {
                            // Tentar usar diretamente primeiro
                            audioElement.src = audioUrl;
                            audioElement.type = audioType;
                            audioElement.load();
                            
                            // Se falhar, tentar baixar e converter para blob
                            audioElement.addEventListener('error', async function onError() {
                                audioElement.removeEventListener('error', onError);
                                console.log('⚠️ Erro ao carregar diretamente, tentando blob...');
                                try {
                                    const response = await fetch(audioUrl);
                                    if (response.ok) {
                                        const blob = await response.blob();
                                        const blobUrl = URL.createObjectURL(blob);
                                        audioElement.src = blobUrl;
                                        audioElement.type = audioType;
                                        audioElement.load();
                                    }
                                } catch (fetchError) {
                                    console.error('❌ Erro ao baixar e converter para blob:', fetchError);
                                }
                            }, { once: true });
                        } catch (error) {
                            console.error('❌ Erro ao configurar áudio:', error);
                        }
                    })();
                }
                
                // Adicionar event listeners para debug
                audioElement.addEventListener('loadstart', () => {
                    console.log('🔄 Áudio começou a carregar');
                });
                
                audioElement.addEventListener('canplay', () => {
                    console.log('✅ Áudio pronto para reproduzir');
                });
                
                audioElement.addEventListener('error', (e) => {
                    console.error('❌ Erro ao carregar áudio:', e);
                    console.error('URL tentada:', audioElement.src);
                });
            }
            
            if (isNew) {
                scrollToBottom();
            }
        }

        // Iniciar resposta a uma mensagem
        window.startReply = function(messageId) {
            const message = messagesCache.get(messageId);
            if (!message) return;

            replyingToMessage = message;
            
            const senderName = message.remetente_id === currentUserId 
                ? (currentUserData?.nome || 'Você') 
                : (message.remetente_nome || 'Usuário');
            const messageText = message.mensagem.length > 60 
                ? message.mensagem.substring(0, 60) + '...' 
                : message.mensagem;

            document.getElementById('replyPreviewAuthor').textContent = senderName;
            document.getElementById('replyPreviewText').textContent = messageText;
            document.getElementById('replyPreviewContainer').style.display = 'flex';
            
            // Focar no input
            document.getElementById('messageInput').focus();
        }

        // Cancelar resposta
        function cancelReply() {
            replyingToMessage = null;
            document.getElementById('replyPreviewContainer').style.display = 'none';
        }

        // Gerenciar seleção de arquivo
        function initFileUpload() {
            const fileInput = document.getElementById('fileInput');
            const attachButton = document.getElementById('attachButton');
            const filePreviewClose = document.getElementById('filePreviewClose');

            attachButton.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleFileSelect(file);
                }
            });

            filePreviewClose.addEventListener('click', () => {
                clearSelectedFile();
            });
        }

        // Inicializar gravação de áudio
        function initAudioRecording() {
            const audioButton = document.getElementById('audioButton');
            const audioRecordingStop = document.getElementById('audioRecordingStop');
            const audioPreviewClose = document.getElementById('audioPreviewClose');

            audioButton.addEventListener('click', async () => {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    // Se já está gravando, parar
                    stopRecording();
                } else {
                    // Iniciar gravação
                    await startRecording();
                }
            });

            audioRecordingStop.addEventListener('click', () => {
                stopRecording();
            });

            audioPreviewClose.addEventListener('click', () => {
                cancelAudioRecording();
            });
        }

        // Inicializar busca de mensagens
        function initSearch() {
            const searchButton = document.getElementById('searchButton');
            const searchModal = document.getElementById('searchModal');
            const searchModalClose = document.getElementById('searchModalClose');
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');

            // Abrir modal de busca
            searchButton.addEventListener('click', () => {
                searchModal.style.display = 'flex';
                searchInput.focus();
            });

            // Fechar modal
            searchModalClose.addEventListener('click', () => {
                closeSearchModal();
            });

            // Fechar ao clicar fora
            searchModal.addEventListener('click', (e) => {
                if (e.target === searchModal) {
                    closeSearchModal();
                }
            });

            // Fechar com ESC
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && searchModal.style.display === 'flex') {
                    closeSearchModal();
                }
            });

            // Buscar ao digitar
            let searchTimeout;
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                const query = e.target.value.trim();
                
                if (query.length === 0) {
                    searchResults.innerHTML = '<div class="search-empty"><i class="fas fa-search"></i><p>Digite para buscar mensagens</p></div>';
                    return;
                }

                searchTimeout = setTimeout(() => {
                    searchMessages(query);
                }, 300); // Debounce de 300ms
            });
        }

        function closeSearchModal() {
            const searchModal = document.getElementById('searchModal');
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            
            searchModal.style.display = 'none';
            searchInput.value = '';
            searchResults.innerHTML = '<div class="search-empty"><i class="fas fa-search"></i><p>Digite para buscar mensagens</p></div>';
        }

        // Buscar mensagens
        async function searchMessages(query) {
            // Verificar se está em modo grupo ou conversa individual
            if ((!selectedUserId && !selectedGrupoId) || !query) return;

            const searchResults = document.getElementById('searchResults');
            searchResults.innerHTML = '<div class="search-empty"><i class="fas fa-spinner fa-spin"></i><p>Buscando...</p></div>';

            try {
                let queryBuilder;
                
                // Se estiver em modo grupo
                if (isGrupoMode && selectedGrupoId) {
                    queryBuilder = supabaseClient
                        .from('chat_mensagens')
                        .select('*')
                        .eq('grupo_id', selectedGrupoId)
                        .ilike('mensagem', `%${query}%`)
                        .order('created_at', { ascending: false })
                        .limit(50);
                } else {
                    // Modo conversa individual
                    queryBuilder = supabaseClient
                        .from('chat_mensagens')
                        .select('*')
                        .or(`and(remetente_id.eq.${currentUserId},destinatario_id.eq.${selectedUserId}),and(remetente_id.eq.${selectedUserId},destinatario_id.eq.${currentUserId})`)
                        .ilike('mensagem', `%${query}%`)
                        .order('created_at', { ascending: false })
                        .limit(50);
                }

                const { data: messages, error } = await queryBuilder;

                if (error) throw error;

                if (!messages || messages.length === 0) {
                    searchResults.innerHTML = '<div class="search-empty"><i class="fas fa-search"></i><p>Nenhuma mensagem encontrada</p></div>';
                    return;
                }

                // Renderizar resultados
                const resultsHtml = messages.map(message => {
                    const isSent = message.remetente_id === currentUserId;
                    const senderName = isSent ? (currentUserData?.nome || 'Você') : (message.remetente_nome || 'Usuário');
                    const messageDate = new Date(message.created_at);
                    const dateStr = messageDate.toLocaleDateString('pt-BR');
                    const timeStr = messageDate.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                    
                    // Destacar termo de busca
                    let highlightedText = escapeHtml(message.mensagem);
                    const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
                    highlightedText = highlightedText.replace(regex, '<span class="search-highlight">$1</span>');

                    return `
                        <div class="search-result-item" data-message-id="${message.id}" onclick="scrollToMessage('${message.id}')">
                            <div class="search-result-text">${highlightedText}</div>
                            <div class="search-result-meta">
                                <span><i class="fas fa-user"></i> ${escapeHtml(senderName)}</span>
                                <span><i class="fas fa-calendar"></i> ${dateStr}</span>
                                <span><i class="fas fa-clock"></i> ${timeStr}</span>
                            </div>
                        </div>
                    `;
                }).join('');

                searchResults.innerHTML = resultsHtml;
            } catch (error) {
                console.error('Erro ao buscar mensagens:', error);
                searchResults.innerHTML = '<div class="search-empty"><i class="fas fa-exclamation-triangle"></i><p>Erro ao buscar mensagens</p></div>';
            }
        }

        // Função auxiliar para escapar regex
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Scroll para mensagem específica
        window.scrollToMessage = async function(messageId) {
            // Fechar modal de busca primeiro
            closeSearchModal();
            
            // Aguardar um pouco para o modal fechar
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Verificar se a mensagem está no DOM
            let messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            
            if (!messageElement) {
                // Mensagem não está no DOM, buscar e carregar mensagens ao redor
                console.log('📋 Mensagem não encontrada no DOM, carregando...');
                
                try {
                    // Buscar a mensagem específica
                    const { data: targetMessage, error } = await supabaseClient
                        .from('chat_mensagens')
                        .select('*')
                        .eq('id', messageId)
                        .single();
                    
                    if (error || !targetMessage) {
                        console.error('Erro ao buscar mensagem:', error);
                        alert('Mensagem não encontrada');
                        return;
                    }
                    
                    // Determinar se é grupo ou conversa individual baseado na mensagem encontrada
                    const isGroupMessage = targetMessage.grupo_id !== null;
                    
                    // Buscar mensagens ao redor (antes e depois)
                    let queryBuilder;
                    
                    if (isGroupMessage) {
                        // Modo grupo
                        queryBuilder = supabaseClient
                            .from('chat_mensagens')
                            .select('*')
                            .eq('grupo_id', targetMessage.grupo_id)
                            .gte('created_at', new Date(new Date(targetMessage.created_at).getTime() - 24 * 60 * 60 * 1000).toISOString()) // 24h antes
                            .lte('created_at', new Date(new Date(targetMessage.created_at).getTime() + 24 * 60 * 60 * 1000).toISOString()) // 24h depois
                            .order('created_at', { ascending: true });
                    } else {
                        // Modo conversa individual
                        queryBuilder = supabaseClient
                            .from('chat_mensagens')
                            .select('*')
                            .or(`and(remetente_id.eq.${currentUserId},destinatario_id.eq.${targetMessage.destinatario_id || targetMessage.remetente_id}),and(remetente_id.eq.${targetMessage.destinatario_id || targetMessage.remetente_id},destinatario_id.eq.${currentUserId})`)
                            .is('grupo_id', null) // Garantir que não é mensagem de grupo
                            .gte('created_at', new Date(new Date(targetMessage.created_at).getTime() - 24 * 60 * 60 * 1000).toISOString()) // 24h antes
                            .lte('created_at', new Date(new Date(targetMessage.created_at).getTime() + 24 * 60 * 60 * 1000).toISOString()) // 24h depois
                            .order('created_at', { ascending: true });
                    }
                    
                    const { data: nearbyMessages, error: nearbyError } = await queryBuilder;
                    
                    if (!nearbyError && nearbyMessages) {
                        // Limpar mensagens atuais
                        const messagesEl = document.getElementById('chatMessages');
                        messagesEl.innerHTML = '';
                        
                        // Adicionar mensagens ao redor
                        nearbyMessages.forEach(msg => {
                            addMessageToUI(msg, false);
                        });
                        
                        // Aguardar um pouco para o DOM atualizar
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        // Tentar encontrar a mensagem novamente
                        messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                    }
                } catch (error) {
                    console.error('Erro ao carregar mensagem:', error);
                    alert('Erro ao carregar mensagem');
                    return;
                }
            }
            
            if (messageElement) {
                // Destacar mensagem com animação
                messageElement.classList.add('highlighted');
                
                // Scroll suave até a mensagem
                setTimeout(() => {
                    messageElement.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center',
                        inline: 'nearest'
                    });
                }, 100);
                
                // Remover destaque após 3 segundos
                setTimeout(() => {
                    messageElement.classList.remove('highlighted');
                }, 3000);
            } else {
                console.error('Mensagem não encontrada após carregamento');
                alert('Mensagem não encontrada');
            }
        };

        // Iniciar gravação de áudio
        async function startRecording() {
            try {
                // Solicitar permissão de microfone
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Criar MediaRecorder
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    // Criar blob do áudio
                    audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    
                    // Parar o stream
                    stream.getTracks().forEach(track => track.stop());
                    
                    // Mostrar preview do áudio
                    showAudioPreview();
                };
                
                // Iniciar gravação
                mediaRecorder.start();
                recordingStartTime = Date.now();
                
                // Atualizar UI
                const audioButton = document.getElementById('audioButton');
                audioButton.classList.add('recording');
                audioButton.innerHTML = '<i class="fas fa-stop"></i>';
                
                // Mostrar container de gravação
                document.getElementById('audioRecordingContainer').style.display = 'flex';
                
                // Iniciar timer
                startRecordingTimer();
                
            } catch (error) {
                console.error('Erro ao iniciar gravação:', error);
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    alert('❌ Permissão de microfone negada.\n\nPor favor, permita o acesso ao microfone nas configurações do navegador.');
                } else {
                    alert('❌ Erro ao acessar o microfone.\n\n' + error.message);
                }
            }
        }

        // Parar gravação
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                
                // Atualizar UI
                const audioButton = document.getElementById('audioButton');
                audioButton.classList.remove('recording');
                audioButton.innerHTML = '<i class="fas fa-microphone"></i>';
                
                // Ocultar container de gravação
                document.getElementById('audioRecordingContainer').style.display = 'none';
                
                // Parar timer
                stopRecordingTimer();
            }
        }

        // Cancelar gravação
        function cancelAudioRecording() {
            // Limpar áudio
            audioBlob = null;
            audioChunks = [];
            
            // Ocultar preview
            document.getElementById('audioPreviewContainer').style.display = 'none';
            
            // Limpar player
            const audioPlayer = document.getElementById('audioPreviewPlayer');
            audioPlayer.src = '';
        }

        // Mostrar preview do áudio
        function showAudioPreview() {
            if (!audioBlob) return;
            
            const audioPlayer = document.getElementById('audioPreviewPlayer');
            const audioUrl = URL.createObjectURL(audioBlob);
            audioPlayer.src = audioUrl;
            
            // Mostrar container de preview
            document.getElementById('audioPreviewContainer').style.display = 'flex';
        }

        // Timer de gravação
        function startRecordingTimer() {
            recordingTimer = setInterval(() => {
                if (recordingStartTime) {
                    const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                    document.getElementById('audioRecordingTime').textContent = timeString;
                }
            }, 1000);
        }

        function stopRecordingTimer() {
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
            recordingStartTime = null;
        }

        // Processar arquivo selecionado
        function handleFileSelect(file) {
            // Validar tamanho (máximo 50MB)
            const maxSize = 50 * 1024 * 1024; // 50MB
            if (file.size > maxSize) {
                alert('Arquivo muito grande! Tamanho máximo: 50MB');
                return;
            }

            selectedFile = file;
            showFilePreview(file);
        }

        // Mostrar preview do arquivo
        function showFilePreview(file) {
            const container = document.getElementById('filePreviewContainer');
            const nameEl = document.getElementById('filePreviewName');
            const sizeEl = document.getElementById('filePreviewSize');
            const iconEl = document.getElementById('filePreviewIcon');

            nameEl.textContent = file.name;
            sizeEl.textContent = formatFileSize(file.size);

            // Mudar ícone baseado no tipo
            if (file.type.startsWith('image/')) {
                iconEl.className = 'fas fa-image';
            } else if (file.type.startsWith('video/')) {
                iconEl.className = 'fas fa-video';
            } else if (file.type.includes('pdf')) {
                iconEl.className = 'fas fa-file-pdf';
            } else if (file.type.includes('word') || file.name.endsWith('.doc') || file.name.endsWith('.docx')) {
                iconEl.className = 'fas fa-file-word';
            } else if (file.type.includes('excel') || file.name.endsWith('.xls') || file.name.endsWith('.xlsx')) {
                iconEl.className = 'fas fa-file-excel';
            } else {
                iconEl.className = 'fas fa-file';
            }

            container.style.display = 'flex';
        }

        // Limpar arquivo selecionado
        function clearSelectedFile() {
            selectedFile = null;
            document.getElementById('fileInput').value = '';
            document.getElementById('filePreviewContainer').style.display = 'none';
        }

        // Formatar tamanho do arquivo
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // Obter ícone do arquivo baseado no tipo
        function getFileIcon(fileType, fileName) {
            if (fileType) {
                if (fileType.startsWith('image/')) return 'fas fa-image';
                if (fileType.startsWith('video/')) return 'fas fa-video';
                if (fileType.startsWith('audio/')) return 'fas fa-music';
                if (fileType.includes('pdf')) return 'fas fa-file-pdf';
                if (fileType.includes('word') || fileType.includes('document')) return 'fas fa-file-word';
                if (fileType.includes('excel') || fileType.includes('spreadsheet')) return 'fas fa-file-excel';
                if (fileType.includes('powerpoint') || fileType.includes('presentation')) return 'fas fa-file-powerpoint';
                if (fileType.includes('zip') || fileType.includes('rar') || fileType.includes('archive')) return 'fas fa-file-archive';
            }
            
            // Fallback baseado na extensão
            if (fileName) {
                const ext = fileName.split('.').pop().toLowerCase();
                if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'].includes(ext)) return 'fas fa-image';
                if (['mp4', 'avi', 'mov', 'wmv', 'flv', 'webm'].includes(ext)) return 'fas fa-video';
                if (['mp3', 'wav', 'ogg', 'flac', 'aac'].includes(ext)) return 'fas fa-music';
                if (['pdf'].includes(ext)) return 'fas fa-file-pdf';
                if (['doc', 'docx'].includes(ext)) return 'fas fa-file-word';
                if (['xls', 'xlsx'].includes(ext)) return 'fas fa-file-excel';
                if (['ppt', 'pptx'].includes(ext)) return 'fas fa-file-powerpoint';
                if (['zip', 'rar', '7z', 'tar', 'gz'].includes(ext)) return 'fas fa-file-archive';
            }
            
            return 'fas fa-file';
        }

        // Verificar se o bucket existe
        async function verificarBucketChatFiles() {
            try {
                if (!supabaseClient) return false;

                // Primeiro, tentar verificar diretamente tentando acessar o bucket
                // Isso funciona mesmo se não tivermos permissão para listar buckets
                try {
                    const { data, error } = await supabaseClient.storage
                        .from('chat-files')
                        .list('', { limit: 1 });
                    
                    // Se não deu erro de "bucket not found", o bucket existe
                    if (!error) {
                        console.log('✅ Bucket "chat-files" acessível!');
                        return true;
                    }
                    
                    // Se o erro não é de "bucket não encontrado", pode ser problema de permissão
                    if (error && !error.message?.includes('not found') && !error.message?.includes('Bucket not found')) {
                        console.log('✅ Bucket "chat-files" existe (erro de permissão, mas bucket está lá)');
                        return true; // Bucket existe, mas pode ter problema de permissão
                    }
                } catch (e) {
                    // Ignorar e tentar listar buckets
                }

                // Tentar listar buckets (pode não ter permissão)
                const { data: buckets, error: listError } = await supabaseClient.storage.listBuckets();
                
                if (!listError && buckets && buckets.length > 0) {
                    const bucketNames = buckets.map(b => b.name);
                    const bucketExists = buckets.some(b => b.name === 'chat-files' || b.name.toLowerCase() === 'chat-files');
                    
                    if (bucketExists) {
                        const foundBucket = buckets.find(b => b.name === 'chat-files' || b.name.toLowerCase() === 'chat-files');
                        console.log(`✅ Bucket encontrado: "${foundBucket.name}"`);
                        return true;
                    } else {
                        console.warn('⚠️ Bucket "chat-files" não encontrado na lista.');
                        console.log('📦 Buckets disponíveis:', bucketNames.join(', ') || 'Nenhum');
                        console.log('💡 Dica: Verifique se o nome do bucket está exatamente como "chat-files" (com hífen)');
                    }
                } else if (listError) {
                    console.warn('⚠️ Não foi possível listar buckets (pode ser problema de permissões)');
                    console.log('💡 Tentando usar o bucket diretamente...');
                    // Retornar true para tentar usar mesmo assim
                    return true;
                }
                
                return false;
            } catch (error) {
                console.warn('⚠️ Erro ao verificar bucket:', error);
                // Em caso de dúvida, retornar true para tentar usar
                return true;
            }
        }

        // Tentar criar o bucket (se tiver permissões)
        async function criarBucketChatFiles() {
            try {
                const { data, error } = await supabaseClient.storage.createBucket('chat-files', {
                    public: false, // Não público por padrão
                    fileSizeLimit: 52428800, // 50MB
                    allowedMimeTypes: null // Permitir todos os tipos
                });

                if (error) {
                    // Se o bucket já existe, não é erro
                    if (error.message && error.message.includes('already exists')) {
                        console.log('✅ Bucket "chat-files" já existe!');
                        return true;
                    }
                    console.warn('⚠️ Não foi possível criar bucket:', error.message);
                    return false;
                }

                console.log('✅ Bucket "chat-files" criado com sucesso!');
                return true;
            } catch (error) {
                console.warn('⚠️ Erro ao criar bucket:', error);
                return false;
            }
        }

        // Fazer upload do arquivo para Supabase Storage
        async function uploadFile(file) {
            try {
                const fileExt = file.name.split('.').pop();
                const fileName = `${currentUserId}/${Date.now()}_${Math.random().toString(36).substring(7)}.${fileExt}`;
                const filePath = `chat-interno/${fileName}`;

                // Tentar fazer upload diretamente
                let { data, error } = await supabaseClient.storage
                    .from('chat-files')
                    .upload(filePath, file, {
                        cacheControl: '3600',
                        upsert: false
                    });

                // Se o bucket não existir, tentar criar
                if (error && (error.message?.includes('Bucket not found') || error.message?.includes('not found'))) {
                    console.log('🔄 Tentando criar bucket "chat-files"...');
                    const bucketCriado = await criarBucketChatFiles();
                    
                    if (bucketCriado) {
                        // Tentar upload novamente após criar o bucket
                        const retry = await supabaseClient.storage
                            .from('chat-files')
                            .upload(filePath, file, {
                                cacheControl: '3600',
                                upsert: false
                            });
                        
                        if (retry.error) {
                            error = retry.error;
                        } else {
                            data = retry.data;
                            error = null;
                        }
                    } else {
                        // Se não conseguiu criar, dar instruções detalhadas
                        const { data: buckets } = await supabaseClient.storage.listBuckets();
                        const bucketNames = buckets?.map(b => b.name).join(', ') || 'Nenhum bucket encontrado';
                        
                        throw new Error(
                            `Bucket "chat-files" não encontrado e não foi possível criar automaticamente.\n\n` +
                            `📋 Instruções:\n` +
                            `1. Acesse: https://supabase.com/dashboard\n` +
                            `2. Selecione seu projeto\n` +
                            `3. Vá em: Storage → New bucket\n` +
                            `4. Nome: chat-files (exatamente assim, com hífen)\n` +
                            `5. Marque como: Public (ou configure políticas RLS)\n` +
                            `6. Clique em: Create bucket\n\n` +
                            `📦 Buckets disponíveis: ${bucketNames}\n\n` +
                            `💡 Após criar, configure as políticas:\n` +
                            `- SELECT: authenticated\n` +
                            `- INSERT: authenticated`
                        );
                    }
                }

                if (error) {
                    console.error('Erro detalhado do upload:', error);
                    
                    // Mensagens de erro mais específicas
                    if (error.statusCode === 400 || error.status === 400) {
                        throw new Error(
                            `Erro 400 ao fazer upload.\n\n` +
                            `Isso geralmente indica problema de permissões.\n\n` +
                            `📋 Configure as políticas do bucket "chat-files":\n\n` +
                            `1. Acesse: Storage → chat-files → Policies\n` +
                            `2. Adicione política para INSERT:\n` +
                            `   - Policy name: "Upload para autenticados"\n` +
                            `   - Allowed operation: INSERT\n` +
                            `   - Target roles: authenticated\n` +
                            `   - USING expression: true\n` +
                            `   - WITH CHECK expression: true\n\n` +
                            `3. Adicione política para SELECT:\n` +
                            `   - Policy name: "Leitura para autenticados"\n` +
                            `   - Allowed operation: SELECT\n` +
                            `   - Target roles: authenticated\n` +
                            `   - USING expression: true`
                        );
                    }
                    
                    if (error.message && error.message.includes('new row violates row-level security')) {
                        throw new Error(
                            `Erro de permissão (RLS).\n\n` +
                            `O bucket existe, mas as políticas RLS não permitem o upload.\n\n` +
                            `📋 Configure as políticas no Supabase Dashboard:\n` +
                            `Storage → chat-files → Policies → New Policy`
                        );
                    }
                    
                    throw new Error(error.message || 'Erro ao fazer upload do arquivo');
                }

                // Obter URL pública
                const { data: { publicUrl } } = supabaseClient.storage
                    .from('chat-files')
                    .getPublicUrl(filePath);

                return {
                    url: publicUrl,
                    path: filePath,
                    name: file.name,
                    type: file.type,
                    size: file.size
                };
            } catch (error) {
                console.error('Erro ao fazer upload:', error);
                throw error;
            }
        }

        // Enviar mensagem
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            // Permitir enviar se houver mensagem OU arquivo OU áudio
            // Verificar se está em modo grupo ou conversa individual
            if ((!message && !selectedFile && !audioBlob) || (!selectedUserId && !selectedGrupoId)) return;

            const sendBtn = document.getElementById('sendButton');
            sendBtn.disabled = true;

            try {
                // Buscar nome do remetente
                const remetenteNome = currentUserData?.nome || 'Usuário';

                // Fazer upload do arquivo se houver
                let fileData = null;
                if (selectedFile) {
                    try {
                        fileData = await uploadFile(selectedFile);
                    } catch (uploadError) {
                        // Exibir erro de forma mais amigável
                        const errorMsg = uploadError.message || 'Erro desconhecido ao fazer upload';
                        alert(`❌ Erro ao fazer upload do arquivo\n\n${errorMsg}\n\nVerifique:\n• Se o bucket "chat-files" existe no Supabase Storage\n• Se as políticas de acesso estão configuradas\n• Se o bucket permite uploads para usuários autenticados`);
                        sendBtn.disabled = false;
                        return;
                    }
                }

                // Fazer upload do áudio se houver
                let audioData = null;
                if (audioBlob) {
                    try {
                        // Criar arquivo a partir do blob com tipo explícito
                        const audioFileName = `audio_${Date.now()}.webm`;
                        const audioFile = new File([audioBlob], audioFileName, { 
                            type: 'audio/webm',
                            lastModified: Date.now()
                        });
                        
                        // Fazer upload
                        audioData = await uploadFile(audioFile);
                        
                        // Garantir que o tipo seja sempre audio/webm
                        if (audioData) {
                            audioData.type = 'audio/webm';
                            audioData.name = audioFileName;
                        }
                    } catch (uploadError) {
                        const errorMsg = uploadError.message || 'Erro desconhecido ao fazer upload do áudio';
                        alert(`❌ Erro ao fazer upload do áudio\n\n${errorMsg}`);
                        sendBtn.disabled = false;
                        return;
                    }
                }

                const messageData = {
                        remetente_id: currentUserId,
                        remetente_nome: remetenteNome,
                    mensagem: message || (selectedFile ? `📎 ${selectedFile.name}` : '') || (audioBlob ? '🎤 Áudio' : ''),
                        lida: false
                };

                // Adicionar campos de vistos apenas se as colunas existirem (será verificado no backend)
                // Não adicionar aqui para evitar erro se as colunas não existirem

                // Se estiver em modo grupo, adicionar grupo_id, senão adicionar destinatario_id
                if (isGrupoMode && selectedGrupoId) {
                    messageData.grupo_id = selectedGrupoId;
                    // Buscar nome do grupo
                    const grupo = gruposData.find(g => g.id === selectedGrupoId);
                    if (grupo) {
                        messageData.destinatario_nome = grupo.nome;
                    }
                } else {
                    messageData.destinatario_id = selectedUserId;
                    messageData.destinatario_nome = await getDestinatarioNome(selectedUserId);
                }

                // Adicionar dados do arquivo se houver
                if (fileData) {
                    messageData.arquivo_url = fileData.url;
                    messageData.arquivo_nome = fileData.name;
                    messageData.arquivo_tipo = fileData.type;
                    messageData.arquivo_tamanho = fileData.size;
                }

                // Adicionar dados do áudio se houver (usando os mesmos campos de arquivo)
                if (audioData) {
                    messageData.arquivo_url = audioData.url;
                    messageData.arquivo_nome = audioData.name || `audio_${Date.now()}.webm`;
                    messageData.arquivo_tipo = audioData.type || 'audio/webm';
                    messageData.arquivo_tamanho = audioData.size || audioBlob.size;
                    // Garantir que a mensagem tenha conteúdo se for só áudio
                    if (!messageData.mensagem || messageData.mensagem === '') {
                        messageData.mensagem = '🎤 Áudio';
                    }
                }

                // Adicionar reply_to_id se estiver respondendo
                if (replyingToMessage) {
                    messageData.reply_to_id = replyingToMessage.id;
                }

                const { data, error } = await supabaseClient
                    .from('chat_mensagens')
                    .insert([messageData])
                    .select()
                    .single();

                if (error) throw error;

                // Marcar como entregue imediatamente após envio (simula entrega instantânea)
                // Em um sistema real, isso seria feito quando o destinatário recebe a mensagem
                if (data && !isGrupoMode) {
                    // Se já sabemos que entregue não existe, não tentar atualizar
                    if (!columnsChecked || columnsAvailable.entregue) {
                        try {
                            const { data: updatedData, error: updateError } = await supabaseClient
                                .from('chat_mensagens')
                                .update({ entregue: true })
                                .eq('id', data.id)
                                .select()
                                .single();
                            
                            if (!updateError && updatedData) {
                                // Coluna existe e foi atualizada com sucesso
                                markColumnAsAvailable('entregue');
                                // Atualizar no cache e na UI
                                data.entregue = true;
                                messagesCache.set(data.id, data);
                                // Aguardar um pouco para garantir que o DOM foi atualizado
                                setTimeout(() => {
                                    updateMessageStatus(data.id, true, false);
                                }, 100);
                            } else if (updateError) {
                                // Se a coluna entregue não existir, marcar como indisponível
                                if (updateError.code === 'PGRST204' || (updateError.message && updateError.message.includes('entregue'))) {
                                    markColumnAsUnavailable('entregue');
                                }
                            }
                        } catch (updateError) {
                            // Se a coluna entregue não existir, marcar como indisponível
                            if (updateError.code === 'PGRST204' || (updateError.message && updateError.message.includes('entregue'))) {
                                markColumnAsUnavailable('entregue');
                            }
                        }
                    }
                    // Se a coluna não existe, apenas continuar sem atualizar (mensagem já foi enviada)
                }

                // Debug: verificar dados do áudio
                if (audioData) {
                    console.log('✅ Áudio enviado:', {
                        url: data.arquivo_url,
                        nome: data.arquivo_nome,
                        tipo: data.arquivo_tipo,
                        tamanho: data.arquivo_tamanho
                    });
                }

                input.value = '';
                // Resetar altura do textarea após enviar
                ajustarAlturaTextarea();
                clearSelectedFile(); // Limpar arquivo selecionado
                cancelAudioRecording(); // Limpar áudio gravado
                cancelReply(); // Limpar preview de resposta
                
                // Atualizar lastMessageId ANTES de adicionar na UI para evitar duplicatas no polling
                lastMessageId = data.id;
                
                // Adicionar mensagem na UI
                addMessageToUI(data, true);
                
                // Atualizar status do usuário atual (marcar como online)
                updateCurrentUserStatus();
                // Verificar status de outros usuários
                await checkUsersStatus();

                // Atualizar lista de usuários para mostrar última mensagem
                await loadUsers();

            } catch (error) {
                if (error.message && error.message.includes('does not exist')) {
                    console.error('❌ Erro: Colunas não existem na tabela chat_mensagens.');
                    alert('Erro: Tabela não configurada. Execute a migração SQL primeiro. Veja INSTRUCOES-CHAT-INTERNO.md');
                } else {
                    console.error('Erro ao enviar mensagem:', error);
                    alert('Erro ao enviar mensagem. Tente novamente.');
                }
            } finally {
                sendBtn.disabled = false;
                input.focus();
            }
        }

        // Obter nome do destinatário
        async function getDestinatarioNome(userId) {
            try {
                const { data } = await supabaseClient
                    .from('user_profiles')
                    .select('nome')
                    .eq('id', userId)
                    .single();
                return data?.nome || 'Usuário';
            } catch {
                return 'Usuário';
            }
        }

        // Adicionar separador de data
        function addDateSeparator(dateString) {
            const messagesEl = document.getElementById('chatMessages');
            if (!messagesEl) return;

            const messageDate = new Date(dateString);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            let dateText = '';
            if (messageDate.toDateString() === today.toDateString()) {
                dateText = 'Hoje';
            } else if (messageDate.toDateString() === yesterday.toDateString()) {
                dateText = 'Ontem';
            } else {
                dateText = messageDate.toLocaleDateString('pt-BR', {
                    weekday: 'long',
                    day: 'numeric',
                    month: 'long',
                    year: messageDate.getFullYear() !== today.getFullYear() ? 'numeric' : undefined
                });
                // Capitalizar primeira letra
                dateText = dateText.charAt(0).toUpperCase() + dateText.slice(1);
            }

            const dateSeparator = document.createElement('div');
            dateSeparator.className = 'message-date-separator';
            dateSeparator.dataset.date = messageDate.toDateString();
            dateSeparator.innerHTML = `<div class="message-date-separator-text">${dateText}</div>`;
            messagesEl.appendChild(dateSeparator);
        }

        // Marcar mensagens como lidas
        async function markMessagesAsRead() {
            if (!selectedUserId) return;

            try {
                // Se já sabemos que visualizada não existe, usar apenas lida
                if (columnsChecked && !columnsAvailable.visualizada) {
                    const { data: updatedMessages, error } = await supabaseClient
                        .from('chat_mensagens')
                        .update({ lida: true })
                        .eq('destinatario_id', currentUserId)
                        .eq('remetente_id', selectedUserId)
                        .eq('lida', false)
                        .select();

                    if (error) throw error;
                    return;
                }

                // Tentar atualizar com visualizada primeiro (se ainda não sabemos se existe)
                const { data: updatedMessages, error } = await supabaseClient
                    .from('chat_mensagens')
                    .update({ 
                        lida: true,
                        visualizada: true 
                    })
                    .eq('destinatario_id', currentUserId)
                    .eq('remetente_id', selectedUserId)
                    .eq('lida', false)
                    .select();

                if (!error) {
                    // Sucesso - coluna visualizada existe
                    markColumnAsAvailable('visualizada');
                    
                    // Atualizar status na UI para mensagens do remetente
                    if (updatedMessages && updatedMessages.length > 0) {
                        updatedMessages.forEach(msg => {
                            messagesCache.set(msg.id, msg);
                            updateMessageStatus(msg.id, msg.entregue || true, msg.visualizada || false);
                        });
                    }
                    return;
                }
                
                // Se der erro de coluna não existente, marcar como indisponível e tentar apenas com lida
                if (error.code === 'PGRST204' || (error.message && error.message.includes('visualizada'))) {
                    markColumnAsUnavailable('visualizada');
                    
                    // Tentar apenas com lida
                    const { data: updatedMessages2, error: error2 } = await supabaseClient
                        .from('chat_mensagens')
                        .update({ lida: true })
                        .eq('destinatario_id', currentUserId)
                        .eq('remetente_id', selectedUserId)
                        .eq('lida', false)
                        .select();

                    if (error2) throw error2;
                    return;
                }
                
                throw error;
            } catch (error) {
                // Ignorar erros de coluna não existente silenciosamente
                if (error.code === 'PGRST204' || (error.message && error.message.includes('visualizada'))) {
                    markColumnAsUnavailable('visualizada');
                    // Tentar novamente sem visualizada
                    try {
                        await supabaseClient
                            .from('chat_mensagens')
                            .update({ lida: true })
                            .eq('destinatario_id', currentUserId)
                            .eq('remetente_id', selectedUserId)
                            .eq('lida', false);
                    } catch (retryError) {
                        // Ignorar erro silenciosamente
                    }
                    return;
                }
                
                // Para outros erros, apenas logar se não for relacionado a colunas
                if (error.message && !error.message.includes('does not exist') && !error.message.includes('visualizada')) {
                    console.error('Erro ao marcar mensagens como lidas:', error);
                }
            }
        }

        // Atualizar status dos vistos na UI
        function updateMessageStatus(messageId, entregue, visualizada) {
            const messageDiv = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageDiv) return;

            const statusDiv = messageDiv.querySelector('.message-status');
            if (!statusDiv) return;

            // Atualizar HTML do status
            if (visualizada) {
                statusDiv.innerHTML = `
                    <i class="fas fa-check-double message-status-icon message-status-read"></i>
                    <i class="fas fa-check-double message-status-icon message-status-read"></i>
                `;
            } else if (entregue) {
                statusDiv.innerHTML = `
                    <i class="fas fa-check-double message-status-icon message-status-delivered"></i>
                    <i class="fas fa-check-double message-status-icon message-status-delivered"></i>
                `;
            } else {
                statusDiv.innerHTML = `
                    <i class="fas fa-check message-status-icon message-status-sent"></i>
                `;
            }
        }

        // Atualizar status dos vistos das mensagens enviadas em tempo real
        async function updateMessageStatuses() {
            // Apenas para conversas individuais (grupos não têm vistos)
            if (!selectedUserId || isGrupoMode) return;
            
            // Se as colunas não existem, não fazer nada
            if (!columnsAvailable.entregue && !columnsAvailable.visualizada) return;

            try {
                // Montar campos de select baseado nas colunas disponíveis
                let selectFields = 'id';
                if (columnsAvailable.entregue) selectFields += ', entregue';
                if (columnsAvailable.visualizada) selectFields += ', visualizada';

                // Buscar mensagens enviadas para o destinatário atual
                const { data: sentMessages, error } = await supabaseClient
                    .from('chat_mensagens')
                    .select(selectFields)
                    .eq('remetente_id', currentUserId)
                    .eq('destinatario_id', selectedUserId)
                    .is('grupo_id', null)
                    .limit(50);

                if (error) throw error;

                if (sentMessages && sentMessages.length > 0) {
                    sentMessages.forEach(msg => {
                        const cachedMsg = messagesCache.get(msg.id);
                        const entregue = (columnsAvailable.entregue && msg.entregue !== undefined) ? msg.entregue : false;
                        const visualizada = (columnsAvailable.visualizada && msg.visualizada !== undefined) ? msg.visualizada : false;
                        
                        if (cachedMsg) {
                            // Atualizar cache se o status mudou
                            if (cachedMsg.entregue !== entregue || cachedMsg.visualizada !== visualizada) {
                                cachedMsg.entregue = entregue;
                                cachedMsg.visualizada = visualizada;
                                messagesCache.set(msg.id, cachedMsg);
                                updateMessageStatus(msg.id, entregue, visualizada);
                            }
                        } else {
                            // Se não está no cache, apenas atualizar a UI se a mensagem estiver visível
                            updateMessageStatus(msg.id, entregue, visualizada);
                        }
                    });
                }
            } catch (error) {
                // Ignorar erros silenciosamente para não poluir o console
                if (error.message && !error.message.includes('does not exist') && !error.message.includes('visualizada') && !error.message.includes('entregue')) {
                    console.warn('⚠️ Erro ao atualizar status dos vistos:', error);
                }
            }
        }

        // Polling de novas mensagens
        function startMessagesPolling() {
            if (messagesInterval) clearInterval(messagesInterval);

            messagesInterval = setInterval(async () => {
                if (!selectedUserId && !selectedGrupoId) return;

                try {
                    let query;
                    
                    // Se estiver em modo grupo
                    if (isGrupoMode && selectedGrupoId) {
                        query = supabaseClient
                            .from('chat_mensagens')
                            .select('*')
                            .eq('grupo_id', selectedGrupoId)
                            .order('created_at', { ascending: true })
                            .limit(100);
                    } else {
                        // Modo conversa individual
                        query = supabaseClient
                        .from('chat_mensagens')
                        .select('*')
                        .or(`and(remetente_id.eq.${currentUserId},destinatario_id.eq.${selectedUserId}),and(remetente_id.eq.${selectedUserId},destinatario_id.eq.${currentUserId})`)
                        .order('created_at', { ascending: true })
                        .limit(100);
                    }

                    if (lastMessageId) {
                        query.gt('id', lastMessageId);
                    }

                    const { data: newMessages, error } = await query;

                    if (error) throw error;

                    if (newMessages && newMessages.length > 0) {
                        // Filtrar mensagens que já existem no DOM ou no cache (proteção adicional)
                        const messagesEl = document.getElementById('chatMessages');
                        const newUniqueMessages = newMessages.filter(msg => {
                            // Verificar se já existe no DOM
                            const existsInDOM = messagesEl.querySelector(`[data-message-id="${msg.id}"]`);
                            // Verificar se já está no cache
                            const existsInCache = messagesCache.has(msg.id);
                            return !existsInDOM && !existsInCache;
                        });

                        if (newUniqueMessages.length > 0) {
                            // Atualizar lastMessageId com a mensagem mais recente ANTES de adicionar na UI
                            const mostRecentMessage = newUniqueMessages[newUniqueMessages.length - 1];
                            lastMessageId = mostRecentMessage.id;
                            
                            newUniqueMessages.forEach(msg => {
                            addMessageToUI(msg, true);
                        });

                            if (isGrupoMode && selectedGrupoId) {
                                await markMessagesAsReadGrupo(selectedGrupoId);
                            } else {
                        await markMessagesAsRead();
                            }
                        await loadUsers(); // Atualizar contadores
                        }
                    }

                    // Atualizar status dos vistos das mensagens enviadas
                    if (!isGrupoMode) {
                        await updateMessageStatuses();
                    }
                } catch (error) {
                    // Ignorar erros de coluna não existente (será corrigido após migração SQL)
                    if (error.message && error.message.includes('does not exist')) {
                        console.warn('⚠️ Colunas não existem ainda. Execute a migração SQL primeiro.');
                        // Parar o polling até que as colunas sejam criadas
                        if (messagesInterval) {
                            clearInterval(messagesInterval);
                            messagesInterval = null;
                        }
                    } else {
                        console.error('Erro ao buscar novas mensagens:', error);
                    }
                }
            }, 2000); // Polling a cada 2 segundos
        }

        // Atualizar lista de usuários periodicamente
        function startUsersPolling() {
            if (usersInterval) clearInterval(usersInterval);

            usersInterval = setInterval(() => {
                loadUsers();
            }, 10000); // A cada 10 segundos
        }

        // Scroll para baixo
        function scrollToBottom() {
            const messagesEl = document.getElementById('chatMessages');
            setTimeout(() => {
                messagesEl.scrollTop = messagesEl.scrollHeight;
            }, 100);
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Emoji Picker
        const emojis = {
            smileys: ['😀', '😃', '😄', '😁', '😆', '😅', '🤣', '😂', '🙂', '🙃', '😉', '😊', '😇', '🥰', '😍', '🤩', '😘', '😗', '😚', '😙', '😋', '😛', '😜', '🤪', '😝', '🤑', '🤗', '🤭', '🤫', '🤔', '🤐', '🤨', '😐', '😑', '😶', '😏', '😒', '🙄', '😬', '🤥', '😌', '😔', '😪', '🤤', '😴', '😷', '🤒', '🤕', '🤢', '🤮', '🤧', '🥵', '🥶', '😶‍🌫️', '😵', '😵‍💫', '🤯', '🤠', '🥳', '😎', '🤓', '🧐'],
            gestures: ['👋', '🤚', '🖐', '✋', '🖖', '👌', '🤌', '🤏', '✌️', '🤞', '🤟', '🤘', '🤙', '👈', '👉', '👆', '🖕', '👇', '☝️', '👍', '👎', '✊', '👊', '🤛', '🤜', '👏', '🙌', '👐', '🤲', '🤝', '🙏', '✍️', '💪', '🦾', '🦿', '🦵', '🦶', '👂', '🦻', '👃', '🧠', '🫀', '🫁', '🦷', '🦴', '👀', '👁', '👅', '👄'],
            hearts: ['❤️', '🧡', '💛', '💚', '💙', '💜', '🖤', '🤍', '🤎', '💔', '❤️‍🔥', '❤️‍🩹', '💕', '💞', '💓', '💗', '💖', '💘', '💝', '💟', '☮️', '✝️', '☪️', '🕉', '☸️', '✡️', '🔯', '🕎', '☯️', '☦️', '🛐', '⛎', '♈', '♉', '♊', '♋', '♌', '♍', '♎', '♏', '♐', '♑', '♒', '♓', '🆔', '⚛️', '🉑', '☢️', '☣️'],
            objects: ['🎉', '🎊', '🎈', '🎁', '🎀', '🎂', '🎃', '🎄', '🎆', '🎇', '✨', '🎊', '🎋', '🎍', '🎎', '🎏', '🎐', '🎑', '🎒', '🎓', '🎖', '🎗', '🎙', '🎚', '🎛', '🎜', '🎝', '🎞', '🎟', '🎠', '🎡', '🎢', '🎣', '🎤', '🎥', '🎦', '🎧', '🎨', '🎩', '🎪', '🎫', '🎬', '🎭', '🎮', '🎯', '🎰', '🎱', '🎲', '🎳', '🎴', '🎵', '🎶', '🎷', '🎸', '🎹', '🎺', '🎻', '🎼', '🎽', '🎾', '🎿', '🏀', '🏁', '🏂', '🏃', '🏄', '🏅', '🏆', '🏇', '🏈', '🏉', '🏊', '🏋', '🏌', '🏍', '🏎', '🏏', '🏐', '🏑', '🏒', '🏓', '🏔', '🏕', '🏖', '🏗', '🏘', '🏙', '🏚', '🏛', '🏜', '🏝', '🏞', '🏟', '🏠', '🏡', '🏢', '🏣', '🏤', '🏥', '🏦', '🏧', '🏨', '🏩', '🏪', '🏫', '🏬', '🏭', '🏮', '🏯', '🏰', '🏱', '🏲', '🏳', '🏴', '🏵', '🏶', '🏷', '🏸', '🏹', '🏺', '🏻', '🏼', '🏽', '🏾', '🏿'],
            symbols: ['✅', '❌', '❓', '❔', '❕', '❗', '➕', '➖', '➗', '➡️', '⬅️', '⬆️', '⬇️', '↗️', '↘️', '↙️', '↖️', '↕️', '↔️', '↩️', '↪️', '⤴️', '⤵️', '🔀', '🔁', '🔂', '🔃', '🔄', '🔅', '🔆', '🔇', '🔈', '🔉', '🔊', '🔋', '🔌', '🔍', '🔎', '🔏', '🔐', '🔑', '🔒', '🔓', '🔔', '🔕', '🔖', '🔗', '🔘', '🔙', '🔚', '🔛', '🔜', '🔝', '🔞', '🔟', '🔠', '🔡', '🔢', '🔣', '🔤', '🔥', '💧', '🌊', '⭐', '🌟', '💫', '✨', '⚡', '☄️', '💥', '💢', '💦', '💨', '💫', '💬', '💭', '💮', '💯', '💰', '💴', '💵', '💶', '💷', '💸', '💹', '💺', '💻', '💼', '💽', '💾', '💿', '📀', '📁', '📂', '📃', '📄', '📅', '📆', '📇', '📈', '📉', '📊', '📋', '📌', '📍', '📎', '📏', '📐', '📑', '📒', '📓', '📔', '📕', '📖', '📗', '📘', '📙', '📚', '📛', '📜', '📝', '📞', '📟', '📠', '📡', '📢', '📣', '📤', '📥', '📦', '📧', '📨', '📩', '📪', '📫', '📬', '📭', '📮', '📯', '📰', '📱', '📲', '📳', '📴', '📵', '📶', '📷', '📸', '📹', '📺', '📻', '📼', '📽', '📾', '📿', '🔀', '🔁', '🔂', '🔃', '🔄', '🔅', '🔆', '🔇', '🔈', '🔉', '🔊', '🔋', '🔌', '🔍', '🔎', '🔏', '🔐', '🔑', '🔒', '🔓', '🔔', '🔕', '🔖', '🔗', '🔘', '🔙', '🔚', '🔛', '🔜', '🔝', '🔞', '🔟', '🔠', '🔡', '🔢', '🔣', '🔤', '🔥', '💧', '🌊', '⭐', '🌟', '💫', '✨', '⚡', '☄️', '💥', '💢', '💦', '💨', '💫', '💬', '💭', '💮', '💯']
        };

        let currentEmojiCategory = 'smileys';

        function initEmojiPicker() {
            const emojiButton = document.getElementById('emojiButton');
            const emojiPicker = document.getElementById('emojiPicker');
            const emojiGrid = document.getElementById('emojiGrid');
            const categoryButtons = document.querySelectorAll('.emoji-category-btn');

            // Renderizar emojis iniciais
            renderEmojis('smileys');

            // Toggle emoji picker
            emojiButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const isVisible = emojiPicker.style.display !== 'none';
                emojiPicker.style.display = isVisible ? 'none' : 'flex';
            });

            // Fechar ao clicar fora
            document.addEventListener('click', (e) => {
                if (!emojiPicker.contains(e.target) && e.target !== emojiButton) {
                    emojiPicker.style.display = 'none';
                }
            });

            // Trocar categoria
            categoryButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    categoryButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const category = btn.dataset.category;
                    currentEmojiCategory = category;
                    renderEmojis(category);
                });
            });
        }

        function renderEmojis(category) {
            const emojiGrid = document.getElementById('emojiGrid');
            const categoryEmojis = emojis[category] || [];
            
            emojiGrid.innerHTML = categoryEmojis.map(emoji => `
                <div class="emoji-item" data-emoji="${emoji}">${emoji}</div>
            `).join('');

            // Adicionar event listeners aos emojis
            emojiGrid.querySelectorAll('.emoji-item').forEach(item => {
                item.addEventListener('click', () => {
                    const emoji = item.dataset.emoji;
                    insertEmoji(emoji);
                });
            });
        }

        function insertEmoji(emoji) {
            const input = document.getElementById('messageInput');
            const cursorPos = input.selectionStart;
            const textBefore = input.value.substring(0, cursorPos);
            const textAfter = input.value.substring(cursorPos);
            input.value = textBefore + emoji + textAfter;
            input.focus();
            input.setSelectionRange(cursorPos + emoji.length, cursorPos + emoji.length);
            // Ajustar altura após inserir emoji
            ajustarAlturaTextarea();
        }

        // Função para ajustar altura do textarea automaticamente
        function ajustarAlturaTextarea() {
            const textarea = document.getElementById('messageInput');
            if (!textarea) return;
            
            // Resetar altura para calcular scrollHeight corretamente
            textarea.style.height = 'auto';
            
            // Ajustar altura baseado no conteúdo (min 52px, max 150px)
            const scrollHeight = textarea.scrollHeight;
            const minHeight = 52;
            const maxHeight = 150;
            
            if (scrollHeight <= minHeight) {
                textarea.style.height = minHeight + 'px';
            } else if (scrollHeight > maxHeight) {
                textarea.style.height = maxHeight + 'px';
                textarea.style.overflowY = 'auto';
            } else {
                textarea.style.height = scrollHeight + 'px';
                textarea.style.overflowY = 'hidden';
            }
        }

        // Event listeners
        document.getElementById('sendButton').addEventListener('click', sendMessage);
        document.getElementById('replyPreviewClose').addEventListener('click', cancelReply);
        
        const messageInput = document.getElementById('messageInput');
        
        // Ajustar altura ao digitar
        messageInput.addEventListener('input', ajustarAlturaTextarea);
        
        // Ajustar altura ao colar texto
        messageInput.addEventListener('paste', () => {
            setTimeout(ajustarAlturaTextarea, 10);
        });
        
        // Controle de Enter para enviar e Shift+Enter para quebrar linha
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
                // Resetar altura após enviar
                setTimeout(() => {
                    messageInput.style.height = '52px';
                    messageInput.style.overflowY = 'hidden';
                }, 100);
            }
        });

        // Inicializar
        initSupabase().then(async () => {
            startUsersPolling();
            initEmojiPicker();
            initFileUpload();
            initAudioRecording();
            initSearch();
            initUsersSearch();
            
            // Iniciar sistema de status online/offline
            startStatusSystem();
            
            // Verificar bucket na inicialização (silenciosamente)
            const bucketExists = await verificarBucketChatFiles();
            if (!bucketExists) {
                console.warn('⚠️ Bucket "chat-files" não encontrado. A funcionalidade de envio de arquivos pode não funcionar.');
            }
        });

        // Limpar intervalos e marcar como offline ao sair
        window.addEventListener('beforeunload', () => {
            if (messagesInterval) clearInterval(messagesInterval);
            if (usersInterval) clearInterval(usersInterval);
            if (statusUpdateInterval) clearInterval(statusUpdateInterval);
            
            // Tentar marcar usuário como offline (pode não executar se a página fechar muito rápido)
            // O sistema tem cleanup automático que marca como offline usuários inativos há mais de 30 minutos
            if (currentUserId && supabaseClient) {
                // Usar fetch com keepalive para garantir que a requisição seja enviada
                try {
                    const url = `${supabaseClient.supabaseUrl}/rest/v1/rpc/mark_user_offline`;
                    const headers = {
                        'Content-Type': 'application/json',
                        'apikey': supabaseClient.supabaseKey,
                        'Authorization': `Bearer ${supabaseClient.supabaseKey}`
                    };
                    
                    // Tentar fazer requisição com keepalive (mais confiável)
                    fetch(url, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({ p_user_id: currentUserId }),
                        keepalive: true
                    }).catch(() => {
                        // Ignorar erros silenciosamente
                    });
                } catch (e) {
                    // Ignorar erros silenciosamente
                }
            }
        });
        
        // Atualizar status quando a página volta ao foco
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && currentUserId) {
                // Página voltou ao foco, marcar como online novamente
                updateCurrentUserStatus();
            }
        });

        // Variável para armazenar dados da mensagem da imagem no modal
        let currentImageMessage = null;

        // Modal de imagem
        async function openImageModal(imageUrl, fileName, messageId = null) {
            const modal = document.getElementById('imageModal');
            const modalImg = document.getElementById('imageModalImg');
            const modalInfo = document.getElementById('imageModalInfo');
            const modalActions = document.getElementById('imageModalActions');
            
            if (!modal || !modalImg) {
                console.error('❌ Modal de imagem não encontrado');
                return;
            }
            
            console.log('🖼️ Abrindo modal:', { imageUrl, fileName, messageId });
            
            // Armazenar dados da mensagem se disponível
            if (messageId) {
                currentImageMessage = messagesCache.get(messageId) || { id: messageId };
            } else {
                currentImageMessage = null;
            }
            
            // Limpar src anterior para forçar recarregamento
            modalImg.src = '';
            
            // Mostrar modal primeiro - garantir que está visível
            modal.classList.add('active');
            modal.style.display = 'flex';
            modalInfo.textContent = fileName || 'Imagem';
            
            console.log('✅ Modal ativado:', {
                hasActiveClass: modal.classList.contains('active'),
                display: modal.style.display
            });
            
            // Mostrar/ocultar botões de ação
            if (modalActions) {
                modalActions.style.display = messageId ? 'flex' : 'none';
            }
            
            // Verificar se é URL do Supabase Storage e gerar URL assinada se necessário
            let finalImageUrl = imageUrl;
            
            // Se a URL é do Supabase Storage e o bucket não é público, usar URL assinada
            if (imageUrl.includes('supabase.co/storage/v1/object/public/chat-files/')) {
                try {
                    // Extrair o caminho do arquivo da URL
                    // URL format: .../object/public/chat-files/chat-interno/userId/filename.png
                    const urlParts = imageUrl.split('/object/public/chat-files/');
                    if (urlParts.length > 1) {
                        // O caminho já inclui 'chat-interno/', não precisa adicionar novamente
                        const filePath = urlParts[1];
                        
                        // Gerar URL assinada válida por 1 hora
                        const { data, error } = await supabaseClient.storage
                            .from('chat-files')
                            .createSignedUrl(filePath, 3600); // 1 hora
                        
                        if (!error && data?.signedUrl) {
                            finalImageUrl = data.signedUrl;
                            console.log('✅ URL assinada gerada com sucesso');
                        } else {
                            console.warn('⚠️ Não foi possível gerar URL assinada, usando URL original:', error);
                        }
                    }
                } catch (error) {
                    console.warn('⚠️ Erro ao gerar URL assinada, usando URL original:', error);
                }
            }
            
            // Carregar imagem
            modalImg.onload = function() {
                // Imagem carregada com sucesso
                modalImg.style.display = 'block';
            };
            
            modalImg.onerror = function() {
                console.error('Erro ao carregar imagem:', finalImageUrl);
                modalImg.alt = 'Erro ao carregar imagem';
                modalImg.style.display = 'block';
                // Tentar usar a URL original como fallback
                if (finalImageUrl !== imageUrl) {
                    console.log('Tentando URL original como fallback...');
                    modalImg.src = imageUrl;
                }
            };
            
            // Armazenar URL original para download
            modalImg.dataset.originalUrl = imageUrl;
            modalImg.src = finalImageUrl;
            
            // Garantir que o modal está visível
            console.log('🖼️ Modal configurado:', {
                modalActive: modal.classList.contains('active'),
                modalDisplay: modal.style.display,
                imageSrc: finalImageUrl
            });
            
            // Fechar ao clicar fora da imagem ou no botão de fechar (mas não nos botões de ação)
            const closeHandler = function(e) {
                // Não fechar se clicar nos botões de ação ou na imagem
                if (e.target.closest('.image-modal-actions') || 
                    e.target.closest('.image-modal-content')) {
                    return;
                }
                
                if (e.target === modal || e.target.classList.contains('image-modal-close')) {
                    closeImageModal();
                }
            };
            
            // Remover listener anterior se existir
            modal.removeEventListener('click', modal._closeHandler);
            modal._closeHandler = closeHandler;
            modal.addEventListener('click', closeHandler);
            
            // Fechar com ESC
            const escHandler = function(e) {
                if (e.key === 'Escape') {
                    closeImageModal();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }

        function closeImageModal() {
            const modal = document.getElementById('imageModal');
            if (modal) {
                modal.classList.remove('active');
                // Limpar event listener
                if (modal._closeHandler) {
                    modal.removeEventListener('click', modal._closeHandler);
                    modal._closeHandler = null;
                }
            }
        }

        // Download de arquivo
        async function downloadFile(fileUrl, fileName) {
            try {
                const response = await fetch(fileUrl);
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName || 'arquivo';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                console.error('Erro ao fazer download:', error);
                // Fallback: abrir em nova aba
                window.open(fileUrl, '_blank');
            }
        }

        // Responder à mensagem da imagem
        window.replyToImageMessage = function() {
            if (!currentImageMessage || !currentImageMessage.id) {
                console.warn('Nenhuma mensagem disponível para responder');
                return;
            }
            
            // Fechar modal
            closeImageModal();
            
            // Iniciar resposta
            window.startReply(currentImageMessage.id);
            
            // Focar no input
            const input = document.getElementById('messageInput');
            if (input) {
                input.focus();
            }
        };

        // Baixar imagem do modal
        window.downloadImageFromModal = async function() {
            const modalImg = document.getElementById('imageModalImg');
            if (!modalImg || !modalImg.src) {
                console.warn('Imagem não disponível para download');
                return;
            }
            
            try {
                // Buscar a URL assinada ou usar a URL atual
                let downloadUrl = modalImg.src;
                const imageUrl = currentImageMessage?.arquivo_url || modalImg.dataset.originalUrl;
                
                // Se tiver URL original do Supabase Storage, gerar signed URL para download
                if (imageUrl && imageUrl.includes('supabase.co/storage/v1/object/public/chat-files/')) {
                    const urlParts = imageUrl.split('/object/public/chat-files/');
                    if (urlParts.length > 1) {
                        const filePath = urlParts[1];
                        const { data, error } = await supabaseClient.storage
                            .from('chat-files')
                            .createSignedUrl(filePath, 3600);
                        
                        if (!error && data?.signedUrl) {
                            downloadUrl = data.signedUrl;
                        }
                    }
                }
                
                // Criar link de download
                const link = document.createElement('a');
                link.href = downloadUrl;
                link.download = currentImageMessage?.arquivo_nome || 'imagem.png';
                link.target = '_blank';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('✅ Download iniciado');
            } catch (error) {
                console.error('Erro ao baixar imagem:', error);
                alert('Erro ao baixar imagem. Tente novamente.');
            }
        };
    </script>

    <!-- Modal para visualizar imagens -->
    <div id="imageModal" class="image-modal">
        <span class="image-modal-close">&times;</span>
        <img id="imageModalImg" class="image-modal-content" alt="Imagem">
        <div class="image-modal-actions" id="imageModalActions" style="display: none;">
            <button class="image-modal-btn" id="imageModalReply" onclick="replyToImageMessage()">
                <i class="fas fa-reply"></i>
                Responder
            </button>
            <button class="image-modal-btn secondary" id="imageModalDownload" onclick="downloadImageFromModal()">
                <i class="fas fa-download"></i>
                Baixar
            </button>
        </div>
        <div class="image-modal-info" id="imageModalInfo"></div>
    </div>

    <!-- Modal Criar Grupo -->
    <div class="modal fade" id="modalCriarGrupo" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content modal-grupo">
                <div class="modal-header">
                    <h5 class="modal-title"><i class="fas fa-users"></i> Criar Novo Grupo</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="grupoNome" class="form-label">Nome do Grupo *</label>
                        <input type="text" class="form-control" id="grupoNome" placeholder="Ex: Equipe de Desenvolvimento" required>
                    </div>
                    <div class="mb-3">
                        <label for="grupoDescricao" class="form-label">Descrição (opcional)</label>
                        <textarea class="form-control" id="grupoDescricao" rows="3" placeholder="Descreva o propósito do grupo..."></textarea>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Adicionar Participantes *</label>
                        <div class="participantes-list" id="participantesList">
                            <div class="text-center text-muted">
                                <i class="fas fa-spinner fa-spin"></i> Carregando usuários...
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                    <button type="button" class="btn btn-primary" onclick="criarGrupo()">
                        <i class="fas fa-check"></i> Criar Grupo
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Adicionar Participantes -->
    <div class="modal fade" id="modalAdicionarParticipantes" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content modal-grupo">
                <div class="modal-header">
                    <h5 class="modal-title"><i class="fas fa-user-plus"></i> Adicionar Participantes</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <input type="text" class="form-control" id="buscarParticipanteInput" placeholder="Buscar usuários...">
                    </div>
                    <div class="participantes-list" id="participantesAdicionarList">
                        <div class="text-center text-muted">
                            <i class="fas fa-spinner fa-spin"></i> Carregando usuários...
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                    <button type="button" class="btn btn-primary" onclick="adicionarParticipantes()">
                        <i class="fas fa-check"></i> Adicionar
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Gerenciar Grupo -->
    <div class="modal fade" id="modalGerenciarGrupo" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content modal-grupo">
                <div class="modal-header">
                    <h5 class="modal-title"><i class="fas fa-cog"></i> Gerenciar Grupo</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-4">
                        <h6 class="mb-3">Participantes do Grupo</h6>
                        <div class="participantes-list" id="participantesGerenciarList">
                            <div class="text-center text-muted">
                                <i class="fas fa-spinner fa-spin"></i> Carregando participantes...
                            </div>
                        </div>
                    </div>
                    <div class="alert alert-warning" style="background: rgba(239, 68, 68, 0.1); border-color: rgba(239, 68, 68, 0.3); color: #fca5a5;">
                        <i class="fas fa-exclamation-triangle"></i>
                        <strong>Atenção:</strong> Apenas o criador do grupo pode remover participantes ou excluir o grupo.
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-danger" id="btnExcluirGrupo" onclick="confirmarExcluirGrupo()" style="display: none;">
                        <i class="fas fa-trash"></i> Excluir Grupo
                    </button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
                </div>
            </div>
        </div>
    </div>
</body>
</html>

